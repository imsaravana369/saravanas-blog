<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>TypeClass in Purescript #3 — Behind the hood</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">TypeClass in Purescript #3 — Behind the hood</h1>
</header>
<section data-field="subtitle" class="p-summary">
Ever wondered how typeclass works behind the hood?
</section>
<section data-field="body" class="e-content">
<section name="0c00" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="bfe2" id="bfe2" class="graf graf--h3 graf--leading graf--title">Behind the hood — Understanding TypeClasses #3</h3><p name="291b" id="291b" class="graf graf--p graf-after--h3">In the previous <a href="https://imsaravananm.medium.com/introduction-to-type-classes-1-2a7d3be0a70c" data-href="https://imsaravananm.medium.com/introduction-to-type-classes-1-2a7d3be0a70c" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">two</a> articles, we have seen how type class work and what is meant by functional dependency. In this article I will be explaining how type class works in low level, that is, how it will get transpiled to its corresponding backend (As we will be using purescript it’s javascript in our case).</p><figure name="4ce5" id="4ce5" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*13xbPrNinkEFCACBS1MA1g.jpeg" data-width="2400" data-height="1600" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*13xbPrNinkEFCACBS1MA1g.jpeg"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@pluyar?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" data-href="https://unsplash.com/@pluyar?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Shane Aldendorff</a> on <a href="https://unsplash.com/photos/mQHEgroKw2k?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" data-href="https://unsplash.com/photos/mQHEgroKw2k?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><p name="2b25" id="2b25" class="graf graf--p graf-after--figure">Let’s say I have a type class,</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="less" name="8a4d" id="8a4d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">Addable</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">where</span><br />  <span class="hljs-selector-tag">add</span> :: <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">-</span>&gt; <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">-</span>&gt; <span class="hljs-selector-tag">a</span><br />  <span class="hljs-selector-tag">addSelf</span> :: <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">-</span>&gt; <span class="hljs-selector-tag">a</span></span></pre><p name="70c6" id="70c6" class="graf graf--p graf-after--pre">What do you think the above code will transpile to ?</p><p name="5619" id="5619" class="graf graf--p graf-after--p">Do you think a class <code class="markup--code markup--p-code">Addable</code> will be created and two member function will be present inside it?</p><p name="b75f" id="b75f" class="graf graf--p graf-after--p">No!! This is how the above typeclass will get transpiled to,</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="javascript" name="c20e" id="c20e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">var</span> add = <span class="hljs-keyword">function</span> (<span class="hljs-params">dict</span>) {<br />    <span class="hljs-keyword">return</span> dict.<span class="hljs-property">add</span>;<br />};<br /><br /><span class="hljs-keyword">var</span> addSelf = <span class="hljs-keyword">function</span> (<span class="hljs-params">dict</span>) {<br />    <span class="hljs-keyword">return</span> dict.<span class="hljs-property">addSelf</span>;<br />};</span></pre><p name="9ed1" id="9ed1" class="graf graf--p graf-after--pre">What does the argument <code class="markup--code markup--p-code">dict</code> signifies above?</p><p name="b336" id="b336" class="graf graf--p graf-after--p">It’s quite simple but to understand that we have to know how transpiled code of an <code class="markup--code markup--p-code">instance</code> of the above typeclass looks like.</p><p name="d02c" id="d02c" class="graf graf--p graf-after--p">Let’s create a instance for our typeclass,</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="8885" id="8885" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">instance addInt :: Addable <span class="hljs-type">Int</span> <span class="hljs-keyword">where</span><br />  <span class="hljs-keyword">add</span> a b <span class="hljs-operator">=</span> a <span class="hljs-operator">+</span> b<br />  addSelf a <span class="hljs-operator">=</span> a <span class="hljs-operator">+</span> a</span></pre><p name="9095" id="9095" class="graf graf--p graf-after--pre">Now, take a look at the transpiled code,</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="javascript" name="f4c2" id="f4c2" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">var</span> addInt = {<br />    <span class="hljs-attr">add</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) {<br />        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">b</span>) {<br />            <span class="hljs-keyword">return</span> a + b | <span class="hljs-number">0</span>;<br />        };<br />    },<br />    <span class="hljs-attr">addSelf</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) {<br />        <span class="hljs-keyword">return</span> a + a | <span class="hljs-number">0</span>;<br />    }<br />};</span></pre><p name="721f" id="721f" class="graf graf--p graf-after--pre">The above transpiled code is quite straight forward, it’s just an object with two keys (our two function names <code class="markup--code markup--p-code">add</code> and <code class="markup--code markup--p-code">addSelf</code> ) and the values of the keys are their respective implementation.</p><p name="ffb9" id="ffb9" class="graf graf--p graf-after--p">Now what happens when I try to use one of the functions like,</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python-repl" name="68e2" id="68e2" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">add <span class="hljs-number">1</span> <span class="hljs-number">2</span> </span></span></pre><p name="b5bf" id="b5bf" class="graf graf--p graf-after--pre">How the above code will get transpiled to ? Will the compiler directly call <code class="markup--code markup--p-code">addInt(1)(2)</code> ?</p><p name="2411" id="2411" class="graf graf--p graf-after--p">Can we go back and see the transpiled js version of our type class’s <code class="markup--code markup--p-code">add</code> function?</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="csharp" name="82be" id="82be" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">var</span> <span class="hljs-keyword">add</span> = function (dict) {<br />    <span class="hljs-keyword">return</span> dict.<span class="hljs-keyword">add</span>;<br />};</span></pre><p name="e9c7" id="e9c7" class="graf graf--p graf-after--pre">So can you think of a way wherein we can wire both the <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">polymorphic</em></strong> <code class="markup--code markup--p-code">add</code> function and add function (<code class="markup--code markup--p-code">addInt</code> ) from our <strong class="markup--strong markup--p-strong">Int</strong> instance?</p><p name="6041" id="6041" class="graf graf--p graf-after--p">This is how the above call <code class="markup--code markup--p-code">add(1)(2)</code> will get transpiled to</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="scss" name="90b8" id="90b8" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-built_in">add</span>(addInt)(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)</span></pre><p name="7c45" id="7c45" class="graf graf--p graf-after--pre">Can you see? <code class="markup--code markup--p-code">add</code> function is taking 3 arguments, not two? Even though the function signature of <code class="markup--code markup--p-code">add</code> is,</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="rust" name="c227" id="c227" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">add :: a <span class="hljs-punctuation">-&gt;</span> a <span class="hljs-punctuation">-&gt;</span> a</span></pre><p name="809c" id="809c" class="graf graf--p graf-after--pre">Now where we are specifying the type of<code class="markup--code markup--p-code">dict</code>?</p><p name="dffe" id="dffe" class="graf graf--p graf-after--p">But behind the hood, actually the add function’s signature looks like,</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="rust" name="f10c" id="f10c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">add :: forall a. Addable a =&gt; a <span class="hljs-punctuation">-&gt;</span> a <span class="hljs-punctuation">-&gt;</span> a</span></pre><p name="d205" id="d205" class="graf graf--p graf-after--pre">Here our type class <code class="markup--code markup--p-code">Addable</code> is added as a constraint to our function signature, it specifies for any <code class="markup--code markup--p-code">a</code> there exists an <code class="markup--code markup--p-code">Addable</code> instance for <code class="markup--code markup--p-code">a</code></p><p name="afc2" id="afc2" class="graf graf--p graf-after--p">This <code class="markup--code markup--p-code">Addable a</code> is our <code class="markup--code markup--p-code">dict</code> argument.</p><p name="844b" id="844b" class="graf graf--p graf-after--p">Now, coming back to the js version,</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="javascript" name="2734" id="2734" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">var</span> add = <span class="hljs-keyword">function</span> (<span class="hljs-params">dict</span>) {<br />    <span class="hljs-keyword">return</span> dict.<span class="hljs-property">add</span>;<br />};<br /><br /><span class="hljs-keyword">var</span> addInt = { <br />   add :  { <span class="hljs-comment">/* implementation */</span> }, <br />   addSelf :  { <span class="hljs-comment">/* implementation */</span> } <br />}<br /><br /><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(addInt)(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)) <span class="hljs-comment">// just assume we are printing the value</span></span></pre><p name="6d5f" id="6d5f" class="graf graf--p graf-after--pre">The first argument— named as dict, <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">specifies the Addable instance which we are going to use</em></strong>.</p><p name="9f44" id="9f44" class="graf graf--p graf-after--p">Which <code class="markup--code markup--p-code">add</code> function we are going to invoke depends on the instance that gets passed as the first argument.</p><p name="0310" id="0310" class="graf graf--p graf-after--p">Since the first argument is <code class="markup--code markup--p-code">addInt</code> , we are gonna invoke <code class="markup--code markup--p-code">add</code> function from <code class="markup--code markup--p-code">addInt</code> . If we pass <code class="markup--code markup--p-code">addString</code> , then add function will be invoked from that instance.</p><p name="5430" id="5430" class="graf graf--p graf-after--p">This is what that makes the type class truly polymorphic and let us do <a href="https://en.wikipedia.org/wiki/Ad_hoc_polymorphism" data-href="https://en.wikipedia.org/wiki/Ad_hoc_polymorphism" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">ad-hoc polymorphism</a> (different implementation while calling the same function with different types)</p><p name="4fa1" id="4fa1" class="graf graf--p graf-after--p">When I call <code class="markup--code markup--p-code">add</code>function with another type, the <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">corresponding instance</em></strong> will be passed as the first argument</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="scss" name="f7ff" id="f7ff" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-built_in">add</span>(addString)(&quot;hello&quot;)(&quot;world&quot;) </span></pre><p name="a8ac" id="a8ac" class="graf graf--p graf-after--pre">Here, we know <code class="markup--code markup--p-code">add</code> is the polymorphic function, which implementation of <code class="markup--code markup--p-code">add</code> to use (<code class="markup--code markup--p-code">addInt</code> or <code class="markup--code markup--p-code">addString</code> etc) will be chosen by the compiler at <strong class="markup--strong markup--p-strong">COMPILE TIME</strong>, based on the type of arguments. This process is called <a href="https://en.wikipedia.org/wiki/Static_dispatch" data-href="https://en.wikipedia.org/wiki/Static_dispatch" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">static dispatch</a>.</p><p name="f303" id="f303" class="graf graf--p graf-after--p">Static dispatch makes type classes type safe, think about it, can you do</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="csharp" name="ff5a" id="ff5a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">&gt;&gt;&gt; <span class="hljs-keyword">add</span> <span class="hljs-literal">true</span> <span class="hljs-literal">false</span></span></pre><p name="1e85" id="1e85" class="graf graf--p graf-after--pre">Assume there is no boolean instance specified for our Addable type class, then the compiler will throw the below error</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="kotlin" name="6d16" id="6d16" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">  No type <span class="hljs-keyword">class</span> <span class="hljs-title class_">instance</span> <span class="hljs-title">was</span> <span class="hljs-title">found</span> <span class="hljs-title">for</span><br /><br />    Main.Add <span class="hljs-built_in">Boolean</span></span></pre><blockquote name="c019" id="c019" class="graf graf--blockquote graf-after--pre">(To understand how compiler selects the right instance refer <a href="https://medium.com/@imsaravananm/functional-dependencies-understanding-typeclasses-2-5a7826d83c7c" data-href="https://medium.com/@imsaravananm/functional-dependencies-understanding-typeclasses-2-5a7826d83c7c" class="markup--anchor markup--blockquote-anchor" target="_blank">this</a> article)</blockquote><p name="2237" id="2237" class="graf graf--p graf-after--blockquote">The reason behind this error, is that how can we pass an instance in the first argument when its not present in the first place?</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="javascript" name="d145" id="d145" class="graf graf--pre graf-after--p graf--trailing graf--preV2"><span class="pre--content"><span class="hljs-title function_">add</span>(???)(<span class="hljs-literal">true</span>)(<span class="hljs-literal">false</span>) <span class="hljs-comment">// no instance is available for `Addable Boolean`</span></span></pre></div></div></section><section name="8188" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="f59a" id="f59a" class="graf graf--p graf--leading">I hope this article helped you get some clarification regarding the low level implementation of type classes and let you debug when the compiler throws <code class="markup--code markup--p-code">No type class instance was found for xyz</code>.</p><p name="8d80" id="8d80" class="graf graf--p graf-after--p">Thank you for reading ❤️.</p><p name="1d02" id="1d02" class="graf graf--p graf-after--p">Please take a look at my previous two articles regarding type classes.</p><div name="6753" id="6753" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://imsaravananm.medium.com/introduction-to-type-classes-1-2a7d3be0a70c" data-href="https://imsaravananm.medium.com/introduction-to-type-classes-1-2a7d3be0a70c" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://imsaravananm.medium.com/introduction-to-type-classes-1-2a7d3be0a70c"><strong class="markup--strong markup--mixtapeEmbed-strong">Introduction to Type Classes #1</strong><br><em class="markup--em markup--mixtapeEmbed-em">Let’s understand type classes in functional programming !!</em>imsaravananm.medium.com</a><a href="https://imsaravananm.medium.com/introduction-to-type-classes-1-2a7d3be0a70c" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="7140baeecdf11df961b4ce49281e56bf" data-thumbnail-img-id="1*XuRmJB0oN4IdyJMmszauLA.jpeg" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*XuRmJB0oN4IdyJMmszauLA.jpeg);"></a></div><div name="6691" id="6691" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed graf--trailing"><a href="https://imsaravananm.medium.com/functional-dependencies-understanding-typeclasses-2-5a7826d83c7c" data-href="https://imsaravananm.medium.com/functional-dependencies-understanding-typeclasses-2-5a7826d83c7c" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://imsaravananm.medium.com/functional-dependencies-understanding-typeclasses-2-5a7826d83c7c"><strong class="markup--strong markup--mixtapeEmbed-strong">Functional Dependencies — Understanding Typeclasses #2</strong><br><em class="markup--em markup--mixtapeEmbed-em">If you don’t understand functional dependencies, then you don’t understand type classes.</em>imsaravananm.medium.com</a><a href="https://imsaravananm.medium.com/functional-dependencies-understanding-typeclasses-2-5a7826d83c7c" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="7994f02af5dfc40bfa95e5bc9da6f548" data-thumbnail-img-id="1*ZGfW3Uic-T2UoLUCNFvyJw.jpeg" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*ZGfW3Uic-T2UoLUCNFvyJw.jpeg);"></a></div></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@imsaravananm" class="p-author h-card">Saravanan M</a> on <a href="https://medium.com/p/addcc0091266"><time class="dt-published" datetime="2023-01-29T07:28:48.397Z">January 29, 2023</time></a>.</p><p><a href="https://medium.com/@imsaravananm/typeclass-in-purescript-3-behind-the-hood-addcc0091266" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 7, 2023.</p></footer></article></body></html>