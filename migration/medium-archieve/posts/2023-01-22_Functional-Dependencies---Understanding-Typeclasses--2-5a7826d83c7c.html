<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Functional Dependencies — Understanding Typeclasses #2</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Functional Dependencies — Understanding Typeclasses #2</h1>
</header>
<section data-field="subtitle" class="p-summary">
If you don’t understand functional dependencies, then you don’t understand type classes.
</section>
<section data-field="body" class="e-content">
<section name="bff1" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="1b92" id="1b92" class="graf graf--h3 graf--leading graf--title">Functional Dependencies — Understanding Typeclasses #2</h3><p name="27f9" id="27f9" class="graf graf--p graf-after--h3">In the <a href="https://medium.com/@imsaravananm/introduction-to-type-classes-1-2a7d3be0a70c" data-href="https://medium.com/@imsaravananm/introduction-to-type-classes-1-2a7d3be0a70c" class="markup--anchor markup--p-anchor" target="_blank">previous article</a> we have seen a basic introduction to type classes and solved a use case to better understand them. In this article we would be seeing about an important topic in type classes called Functional Dependency.</p><p name="b60c" id="b60c" class="graf graf--p graf-after--p">Before learning what functional dependencies are, let’s first understand in the ocean of instances how the compiler knows which instance to choose.</p><figure name="b412" id="b412" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ZGfW3Uic-T2UoLUCNFvyJw.jpeg" data-width="1920" data-height="1281" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*ZGfW3Uic-T2UoLUCNFvyJw.jpeg"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@flyd2069?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" data-href="https://unsplash.com/@flyd2069?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">FLY:D</a> on <a href="https://unsplash.com/photos/ZNOxwCEj5mw?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" data-href="https://unsplash.com/photos/ZNOxwCEj5mw?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><h4 name="21b9" id="21b9" class="graf graf--h4 graf-after--figure">How type class choose the right instance?</h4><p name="abfd" id="abfd" class="graf graf--p graf-after--h4">Have you ever wondered how type class actually work, if you read my <a href="https://medium.com/@imsaravananm/introduction-to-type-classes-1-2a7d3be0a70c" data-href="https://medium.com/@imsaravananm/introduction-to-type-classes-1-2a7d3be0a70c" class="markup--anchor markup--p-anchor" target="_blank">previous article</a> you may know that each type class can have many instances defined for it.</p><p name="da44" id="da44" class="graf graf--p graf-after--p">For this article, let’s consider <code class="markup--code markup--p-code">Show</code> typeclass as an example, <code class="markup--code markup--p-code">Show</code> has a single method called <code class="markup--code markup--p-code">show :: a -&gt; String</code> , which can convert the passed value <code class="markup--code markup--p-code">a</code> to a String.</p><p name="da4d" id="da4d" class="graf graf--p graf-after--p">If you look at the source code how instances are defined for Show, then it would look something like</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="d7d3" id="d7d3" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">class <span class="hljs-keyword">Show</span> a <span class="hljs-keyword">where</span><br />  <span class="hljs-keyword">show</span> :: a <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> String<br /><br />instance showUnit :: <span class="hljs-keyword">Show</span> Unit <span class="hljs-keyword">where</span><br />  <span class="hljs-keyword">show</span> _ <span class="hljs-operator">=</span> &quot;unit&quot;<br /><br />instance showBoolean :: <span class="hljs-keyword">Show</span> <span class="hljs-type">Boolean</span> <span class="hljs-keyword">where</span><br />  <span class="hljs-keyword">show</span> <span class="hljs-literal">true</span> <span class="hljs-operator">=</span> &quot;true&quot;<br />  <span class="hljs-keyword">show</span> <span class="hljs-literal">false</span> <span class="hljs-operator">=</span> &quot;false&quot;<br /><br />instance showInt :: <span class="hljs-keyword">Show</span> <span class="hljs-type">Int</span> <span class="hljs-keyword">where</span><br />  <span class="hljs-keyword">show</span> <span class="hljs-operator">=</span> showIntImpl <span class="hljs-comment">-- showIntImpl is a Foreign function </span><br /><br />....</span></pre><p name="d2e9" id="d2e9" class="graf graf--p graf-after--pre">Having seen some of the defined instances, let me ask you a question…</p><p name="d549" id="d549" class="graf graf--p graf-after--p">When I call,</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python-repl" name="5a9e" id="5a9e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">show <span class="hljs-number">1</span></span></span></pre><p name="dd80" id="dd80" class="graf graf--p graf-after--pre">What do you think will happen?</p><p name="d113" id="d113" class="graf graf--p graf-after--p">How the compiler chooses the right instance?</p><p name="57ca" id="57ca" class="graf graf--p graf-after--p">When do you think the choosing happens, in compile time or runtime?</p><p name="be84" id="be84" class="graf graf--p graf-after--p graf--trailing">(I think I revealed the answer in the above line itself)</p></div></div></section><section name="63b6" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="31d9" id="31d9" class="graf graf--p graf--leading"><strong class="markup--strong markup--p-strong">How compiler chooses the right instance?</strong></p><p name="8dec" id="8dec" class="graf graf--p graf-after--p">This one is very obvious, if the compiler can infer the type of the value being passed, then it can choose the right instance.. for the above example</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python-repl" name="1450" id="1450" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">show <span class="hljs-number">1</span></span></span></pre><p name="2080" id="2080" class="graf graf--p graf-after--pre">here we know the type of <code class="markup--code markup--p-code">1</code> is Int, so the compiler chooses the <code class="markup--code markup--p-code">Show Int</code> instance.</p><p name="30ab" id="30ab" class="graf graf--p graf-after--p">But what if your type class looks something like,</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="less" name="4ba5" id="4ba5" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">MyCoolTypeClass</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">where</span> <br />  <span class="hljs-selector-tag">convertAToB</span> :: <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">-</span>&gt; <span class="hljs-selector-tag">b</span> <br />  <span class="hljs-selector-tag">convertBToA</span> :: <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">-</span>&gt; <span class="hljs-selector-tag">a</span></span></pre><p name="58a2" id="58a2" class="graf graf--p graf-after--pre">what if I write two instances for <code class="markup--code markup--p-code">MyCollTypeClass</code> as,</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="kotlin" name="8ab9" id="8ab9" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> Data.<span class="hljs-built_in">Int</span>(fromString,toNumber,ceil)<br /><span class="hljs-keyword">import</span> Data.Maybe(fromMaybe)<br /><br />.....<br /><br />instance instance1 :: MyCoolTypeClass <span class="hljs-built_in">Int</span> String <span class="hljs-keyword">where</span> <br />  convertAToB someInt = show someInt<br />  convertBToA someString = fromMaybe <span class="hljs-number">0</span> $ fromString someString<br /><br /><br />instance instance2 :: MyCoolTypeClass <span class="hljs-built_in">Int</span> Number  <span class="hljs-keyword">where</span> <br />  convertAToB someInt = toNumber someInt<br />  convertBToA someNumber = ceil someNumber</span></pre><p name="351d" id="351d" class="graf graf--p graf-after--pre">What would be my return type when I do</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python-repl" name="f258" id="f258" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">let a = convertAToB <span class="hljs-number">12</span></span></span></pre><p name="ea43" id="ea43" class="graf graf--p graf-after--pre">Is <code class="markup--code markup--p-code">a</code> an String or Number because we have two possible functions to choose from,</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="javascript" name="5e6e" id="5e6e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">convertAToB :: <span class="hljs-title class_">Int</span> -&gt; <span class="hljs-title class_">Number</span> -- coming <span class="hljs-keyword">from</span> instance1<br /><br />(and)<br /><br />convertAToB :: <span class="hljs-title class_">Int</span> -&gt; <span class="hljs-title class_">String</span> -- coming <span class="hljs-keyword">from</span> instance2</span></pre><p name="fe7a" id="fe7a" class="graf graf--p graf-after--pre">If the chosen instance is <code class="markup--code markup--p-code"><em class="markup--em markup--p-em">instance1</em></code> then it would be String, if its <code class="markup--code markup--p-code"><em class="markup--em markup--p-em">instance2</em></code> then it would be Number.</p><p name="49ac" id="49ac" class="graf graf--p graf-after--p">Does it depend on the last defined instance, which is <em class="markup--em markup--p-em">instance2</em>😐?</p><p name="aa9a" id="aa9a" class="graf graf--p graf-after--p">No, the compiler will thrown an error</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="typescript" name="6115" id="6115" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">  <span class="hljs-title class_">No</span> <span class="hljs-keyword">type</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">instance</span> was found <span class="hljs-keyword">for</span><br /><br />    <span class="hljs-title class_">Main</span>.<span class="hljs-property">MyCoolTypeClass</span> <span class="hljs-title class_">Int</span><br />                         t1<br /><br />  <span class="hljs-title class_">The</span> instance head contains <span class="hljs-built_in">unknown</span> <span class="hljs-keyword">type</span> variables. <br />  <span class="hljs-title class_">Consider</span> adding a <span class="hljs-keyword">type</span> annotation.</span></pre><p name="6434" id="6434" class="graf graf--p graf-after--pre">its telling, it can’t decide which instance to pick.</p><p name="addf" id="addf" class="graf graf--p graf-after--p">So how do you resolve it?</p><p name="5179" id="5179" class="graf graf--p graf-after--p">By Explicitly giving out the type,</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python-repl" name="a9b1" id="a9b1" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">let a = convertAToB <span class="hljs-number">12</span> :: String</span><br /><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a</span><br /><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-string">&quot;12&quot;</span></span></span></pre><p name="bde9" id="bde9" class="graf graf--p graf-after--pre">We have made the compiler to choose <code class="markup--code markup--p-code">MyCoolTypeClass Int String</code>by explicitly mentioning the type of the second parameterized variable in <code class="markup--code markup--p-code">MyCoolTypeClass</code> (as String).</p><p name="8ede" id="8ede" class="graf graf--p graf-after--p">Compiler can’t decide which instance to pick unless <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">it</em></strong> <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">knows the</em></strong> <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">type of all parameterized variables</em></strong> in the type class. (read it once again)</p><p name="2830" id="2830" class="graf graf--p graf-after--p">Okay, just remember what I just told.</p><p name="3c1a" id="3c1a" class="graf graf--p graf-after--p">Now let’s move on to the next example.</p><blockquote name="3fae" id="3fae" class="graf graf--blockquote graf-after--p"><strong class="markup--strong markup--blockquote-strong">Goal</strong> : I want to create a type class for making api calls, which knows how to create a request object and decode the response.</blockquote><p name="2b0e" id="2b0e" class="graf graf--p graf-after--blockquote">I will call my type class RestEndpoint,</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="rust" name="869e" id="869e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">class RestEndpoint req resp <span class="hljs-keyword">where</span><br />  makeRequest :: req <span class="hljs-punctuation">-&gt;</span> Headers <span class="hljs-punctuation">-&gt;</span> Request<br />  decodeResponse :: <span class="hljs-type">String</span> <span class="hljs-punctuation">-&gt;</span> F resp</span></pre><p name="b295" id="b295" class="graf graf--p graf-after--pre">Consider <code class="markup--code markup--p-code">Headers</code> as a List of Tuple and Request as a newtype of record which holds all the neccassary information to make an api call.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="rust" name="df93" id="df93" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"> <br /><span class="hljs-keyword">type</span> <span class="hljs-title class_">Method</span> = <span class="hljs-type">String</span><br /><span class="hljs-keyword">type</span> <span class="hljs-title class_">URL</span> = <span class="hljs-type">String</span> <br /><br />new<span class="hljs-keyword">type</span> <span class="hljs-title class_">Headers</span> = <span class="hljs-title function_ invoke__">Array</span> (Tuple <span class="hljs-type">String</span> <span class="hljs-type">String</span>)<br /><br />new<span class="hljs-keyword">type</span> <span class="hljs-title class_">Request</span> = Request <br />                  { headers :: Headers<br />                  , method :: Method <br />                  , payload :: <span class="hljs-type">String</span><br />                  , url :: URL }</span></pre><p name="4fc5" id="4fc5" class="graf graf--p graf-after--pre">Now let’s create our request and response type,</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="rust" name="046a" id="046a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">new<span class="hljs-keyword">type</span> <span class="hljs-title class_">CreateOrderRequest</span> = CreateOrderRequest <br />                            {orderId :: <span class="hljs-type">String</span>, amount :: Number }  <br /><br />new<span class="hljs-keyword">type</span> <span class="hljs-title class_">CreateOrderResponse</span> = CreateOrderResponse {status :: <span class="hljs-type">String</span> }<br /><br />--- derive encode,decode instances</span></pre><p name="1c20" id="1c20" class="graf graf--p graf-after--pre">If you are following along, the above code still wont compile</p><p name="6286" id="6286" class="graf graf--p graf-after--p">Now the compiler tells something new,</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="rust" name="3093" id="3093" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">The declaration makeRequest contains arguments that couldn<span class="hljs-symbol">&#x27;t</span> be determined.<br />  These arguments are: { resp }</span></pre><p name="0043" id="0043" class="graf graf--p graf-after--pre">I told you one thing to remember, I will restate it once again</p><blockquote name="6a72" id="6a72" class="graf graf--pullquote graf-after--p">Compiler can’t decide which instance to pick unless <strong class="markup--strong markup--pullquote-strong"><em class="markup--em markup--pullquote-em">it</em></strong> <strong class="markup--strong markup--pullquote-strong"><em class="markup--em markup--pullquote-em">knows the</em></strong> <strong class="markup--strong markup--pullquote-strong"><em class="markup--em markup--pullquote-em">type of all parameterized variables</em></strong> in the type class.</blockquote><p name="c8e6" id="c8e6" class="graf graf--p graf-after--pullquote">If you look at all the type classes(Show and MyCoolTypeClass) we defined before, all the methods have all the type we parameterized the type class with,</p><p name="d337" id="d337" class="graf graf--p graf-after--p">E.g, <code class="markup--code markup--p-code">MyCoolTypeClass</code>has two parameterized type <code class="markup--code markup--p-code">a</code> and <code class="markup--code markup--p-code">b</code> , and both of its method <code class="markup--code markup--p-code">convertAToB</code> and <code class="markup--code markup--p-code">convertBToA</code> has both <code class="markup--code markup--p-code">a</code> and <code class="markup--code markup--p-code">b</code> in their function declaration.</p><p name="ef4a" id="ef4a" class="graf graf--p graf-after--p">But in <code class="markup--code markup--p-code">RestEndPoint</code> typeclasss, we are only passing <code class="markup--code markup--p-code">req</code> to <code class="markup--code markup--p-code">makeRequest</code> then how does the compiler know what the type of <code class="markup--code markup--p-code">resp</code> is, if it doesn’t know what <code class="markup--code markup--p-code">resp</code> is, how does it know which instance to choose?</p><p name="102e" id="102e" class="graf graf--p graf-after--p">The same goes with decodeResponse, you can even try type-annotating it,</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="69ab" id="69ab" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-built_in">let</span> response = decodeResponse someStringFromApicall :: F CreateOrderResponse</span></pre><p name="13ee" id="13ee" class="graf graf--p graf-after--pre">but still the compiler can’t infer what is the type of <code class="markup--code markup--p-code">req</code> is from the above line, so it doesn’t know which instance of RestEndPoint to pick…</p><p name="94d1" id="94d1" class="graf graf--p graf-after--p">So how can we make this work?</p><p name="082e" id="082e" class="graf graf--p graf-after--p">How can we force the compiler to infer the other type when one of the type is known.</p><p name="95b2" id="95b2" class="graf graf--p graf-after--p">Can we have some kind of mapping? Which will let the compiler infer <code class="markup--code markup--p-code">b</code> when <code class="markup--code markup--p-code">a</code>is known, and vice versa.</p><p name="9300" id="9300" class="graf graf--p graf-after--p">Yes, that’s exactly what we can do with functional dependencies.</p><p name="a3c2" id="a3c2" class="graf graf--p graf-after--p">Let’s add functional dependency to our type class,</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="rust" name="d40f" id="d40f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">class RestEndpoint req resp | req <span class="hljs-punctuation">-&gt;</span> resp, resp <span class="hljs-punctuation">-&gt;</span> req <span class="hljs-keyword">where</span><br />  makeRequest :: req <span class="hljs-punctuation">-&gt;</span> Headers <span class="hljs-punctuation">-&gt;</span> Request<br />  decodeResponse :: <span class="hljs-type">String</span> <span class="hljs-punctuation">-&gt;</span> F resp</span></pre><p name="c37e" id="c37e" class="graf graf--p graf-after--pre">If you haven’t noticed, we have added the below lines to our type class,</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="rust" name="41de" id="41de" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">| req <span class="hljs-punctuation">-&gt;</span> resp, resp <span class="hljs-punctuation">-&gt;</span> req </span></pre><blockquote name="8d65" id="8d65" class="graf graf--blockquote graf-after--pre">Note: The syntax start with a pipe <code class="markup--code markup--blockquote-code">|</code> , followed by all the dependencies as <code class="markup--code markup--blockquote-code">| a1 -&gt; a2, a2 -&gt; a3, .....</code></blockquote><p name="1938" id="1938" class="graf graf--p graf-after--blockquote">The functional depedencies above are telling the compiler that,</p><ol class="postList"><li name="351c" id="351c" class="graf graf--li graf-after--p">If you know <code class="markup--code markup--li-code">req</code> type you can infer <code class="markup--code markup--li-code">resp</code></li><li name="fca5" id="fca5" class="graf graf--li graf-after--li">If you know <code class="markup--code markup--li-code">resp</code> type you can infer <code class="markup--code markup--li-code">req</code></li></ol><p name="d626" id="d626" class="graf graf--p graf-after--li">So there’s one to one mapping between <code class="markup--code markup--p-code">req</code> and <code class="markup--code markup--p-code">resp</code></p><p name="ef33" id="ef33" class="graf graf--p graf-after--p">That means, you can’t create,</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="da84" id="da84" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">instance restEndPoint1 :: RestEndpoint Request1 Response1 <span class="hljs-built_in">where</span><br />   ..... <br /><br />instance restEndPoint2 :: RestEndpoint Request1 Response2 <span class="hljs-built_in">where</span><br />   .....</span></pre><p name="28f5" id="28f5" class="graf graf--p graf-after--pre">The compiler will throw error on the second instance, that you can’t define another instance with <code class="markup--code markup--p-code">req</code> as <code class="markup--code markup--p-code">Request1</code></p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="less" name="a769" id="a769" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-selector-tag">Overlapping</span> <span class="hljs-selector-tag">type</span> <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">instances</span> <span class="hljs-selector-tag">found</span> <span class="hljs-selector-tag">for</span><br /><br />    <span class="hljs-selector-tag">Main</span><span class="hljs-selector-class">.RestEndpoint</span> <span class="hljs-selector-tag">Request1</span><br />                      <span class="hljs-selector-tag">Response2</span><br /><br />  <span class="hljs-selector-tag">The</span> <span class="hljs-selector-tag">following</span> <span class="hljs-selector-tag">instances</span> <span class="hljs-selector-tag">were</span> <span class="hljs-selector-tag">found</span>:<br /><br />    <span class="hljs-selector-tag">Main</span><span class="hljs-selector-class">.restEndPoint1</span><br />    <span class="hljs-selector-tag">Main</span><span class="hljs-selector-class">.restEndPoint2</span><br /><br /></span></pre><p name="85f5" id="85f5" class="graf graf--p graf-after--pre">Because <code class="markup--code markup--p-code">req -&gt; resp</code> indicates theres a mapping from <code class="markup--code markup--p-code">req</code> to <code class="markup--code markup--p-code">resp</code> , in the above case <code class="markup--code markup--p-code">Request1</code> is already mapped to <code class="markup--code markup--p-code">Response1</code> , so you can’t map <code class="markup--code markup--p-code">Request1</code> with another <code class="markup--code markup--p-code">Response2</code> ….</p><p name="73be" id="73be" class="graf graf--p graf-after--p">The same thing happens if you try to do it in the reverse order, having different <code class="markup--code markup--p-code">req</code> for a single <code class="markup--code markup--p-code">resp</code> (since <code class="markup--code markup--p-code">resp -&gt; req</code> )</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="34dd" id="34dd" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">instance restEndPoint3 :: RestEndpoint Request1 Response2 <span class="hljs-built_in">where</span><br />   ..... <br /><br />instance restEndPoint4 :: RestEndpoint Request1 Response2 <span class="hljs-built_in">where</span><br />   .....</span></pre><p name="63b2" id="63b2" class="graf graf--p graf-after--pre">There’s not any change in defining the instances,</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="java" name="8ba0" id="8ba0" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">instance instanceCreateOrderRestEndpoint ::RestEndpoint CreateOrderRequest CreateOrderResponse where <br />    makeRequest <span class="hljs-type">req</span> <span class="hljs-variable">headers</span> <span class="hljs-operator">=</span> Request <br />                            { headers : headers<br />                            , method : <span class="hljs-string">&quot;POST&quot;</span><br />                            , payload : encodeJSON req<br />                            , url : <span class="hljs-string">&quot;https://mydomain.com/create/order&quot;</span><br />                            }<br /><br />    <span class="hljs-type">decodeResponse</span> <span class="hljs-variable">resp</span> <span class="hljs-operator">=</span> decodeJSON resp</span></pre><p name="c0bd" id="c0bd" class="graf graf--p graf-after--pre">In your code, you can call <code class="markup--code markup--p-code">makeRequest</code> and <code class="markup--code markup--p-code">decodeResponse</code> with the corresponding <code class="markup--code markup--p-code">Request</code> and <code class="markup--code markup--p-code">Response</code> type, and the compiler can infer the other type on its own, leading to the selection of the right instance.</p><p name="8046" id="8046" class="graf graf--p graf-after--p">It’s not at all possible without the help of functional dependencies.</p><p name="7a7a" id="7a7a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Take away :</strong></p><p name="d1b7" id="d1b7" class="graf graf--p graf-after--p">When your member function (function inside type class), doesn’t have all the parameterized types specified in the type class, then you want functional dependency to help compiler choose the right instance.</p><p name="0b84" id="0b84" class="graf graf--p graf-after--p">Let’s go through the above line with our <code class="markup--code markup--p-code">RestEndPoint</code> type class as an example,</p><ul class="postList"><li name="21e8" id="21e8" class="graf graf--li graf-after--p">When your member function (function inside type class) : <strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">makeRequest and decodeResponse</em></strong></li><li name="5b55" id="5b55" class="graf graf--li graf-after--li">doesn’t have all the parameterized types specified in the type class</li></ul><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="rust" name="4607" id="4607" class="graf graf--pre graf-after--li graf--preV2"><span class="pre--content">--- Doesn<span class="hljs-symbol">&#x27;t</span> have `resp`<br />makeRequest :: req <span class="hljs-punctuation">-&gt;</span> Headers <span class="hljs-punctuation">-&gt;</span> Request <br /><br />--- Doesn<span class="hljs-symbol">&#x27;t</span> have `req`<br />decodeResponse :: <span class="hljs-type">String</span> <span class="hljs-punctuation">-&gt;</span> F resp </span></pre><ul class="postList"><li name="7cad" id="7cad" class="graf graf--li graf-after--pre">then you want functional dependency to help compiler choose the right instance</li></ul><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="rust" name="2f82" id="2f82" class="graf graf--pre graf-after--li graf--trailing graf--preV2"><span class="pre--content">| req <span class="hljs-punctuation">-&gt;</span> resp, resp <span class="hljs-punctuation">-&gt;</span> req</span></pre></div></div></section><section name="f075" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h4 name="b0c6" id="b0c6" class="graf graf--h4 graf--leading">Bonus: More Dependencies</h4><p name="7546" id="7546" class="graf graf--p graf-after--h4">We wrote dependency between one type to another type, like</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="rust" name="5636" id="5636" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">req <span class="hljs-punctuation">-&gt;</span> resp, resp <span class="hljs-punctuation">-&gt;</span> req</span></pre><p name="378a" id="378a" class="graf graf--p graf-after--pre">But have you wondered whether we can create dependency between n types to m types?</p><p name="20cf" id="20cf" class="graf graf--p graf-after--p">Like when we know 2 of the three types, can we infer the third type? and the other way around?</p><p name="c5fb" id="c5fb" class="graf graf--p graf-after--p">Yes its absolutely possible,</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="less" name="097c" id="097c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">DummyClass</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">c</span> | <span class="hljs-selector-tag">c</span> <span class="hljs-selector-tag">-</span>&gt; <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span>, <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">-</span>&gt; <span class="hljs-selector-tag">c</span> <span class="hljs-selector-tag">where</span><br />  <span class="hljs-selector-tag">func1</span> :: <span class="hljs-selector-tag">c</span> <span class="hljs-selector-tag">-</span>&gt; <span class="hljs-selector-tag">String</span><br />  <span class="hljs-selector-tag">func2</span> :: <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">-</span>&gt; <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">-</span>&gt; <span class="hljs-selector-tag">String</span></span></pre><p name="6a26" id="6a26" class="graf graf--p graf-after--pre">The syntax is</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="rust" name="2b35" id="2b35" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">| type1 type2 ... typeN <span class="hljs-punctuation">-&gt;</span> type100 type101 ... typeM</span></pre><p name="512e" id="512e" class="graf graf--p graf-after--pre">when we know <code class="markup--code markup--p-code">type1, type2 .. typeN</code>, we can infer <code class="markup--code markup--p-code">type100, type101 ... typeM</code></p><p name="839d" id="839d" class="graf graf--p graf-after--p graf--trailing">Thanks for reading the article, hope you have learnt a good amount of “functional dependency”. In the next article, lets understand how typeclass work behind the hood.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@imsaravananm" class="p-author h-card">Saravanan M</a> on <a href="https://medium.com/p/5a7826d83c7c"><time class="dt-published" datetime="2023-01-22T07:15:30.008Z">January 22, 2023</time></a>.</p><p><a href="https://medium.com/@imsaravananm/functional-dependencies-understanding-typeclasses-2-5a7826d83c7c" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 7, 2023.</p></footer></article></body></html>