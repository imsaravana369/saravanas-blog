<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Type vs New type‚Ää‚Äî‚ÄäWhen you should prefer the one over the other</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Type vs New type‚Ää‚Äî‚ÄäWhen you should prefer the one over the other</h1>
</header>
<section data-field="subtitle" class="p-summary">
A guide on when to use type vs newtype
</section>
<section data-field="body" class="e-content">
<section name="746e" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="664e" id="664e" class="graf graf--h3 graf--leading graf--title">Type vs New type‚Ää‚Äî‚ÄäWhen you should prefer the one over the¬†other</h3><p name="fed3" id="fed3" class="graf graf--p graf-after--h3">When I started with functional programming, I had many questions. One of them was ‚ÄúWhats the difference between type &amp; newtype and when should I prefer the one over the other?‚Äù In this article, I will try my best to answer that question.</p><figure name="1264" id="1264" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*9fno6-fMBGTdzUG18lTkmQ.jpeg" data-width="2400" data-height="1600" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*9fno6-fMBGTdzUG18lTkmQ.jpeg"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@garciasaldana_?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" data-href="https://unsplash.com/@garciasaldana_?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Pablo Garc√≠a Salda√±a</a> on¬†<a href="https://unsplash.com/s/photos/direction?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" data-href="https://unsplash.com/s/photos/direction?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><p name="c9d7" id="c9d7" class="graf graf--p graf-after--figure">So first let‚Äôs see the definition of both,</p><blockquote name="039c" id="039c" class="graf graf--blockquote graf-after--p"><code class="markup--code markup--blockquote-code"><strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">type</em></strong></code>‚Ää‚Äî‚Ääintroduces a synonym for a type and uses the same data constructors</blockquote><blockquote name="9dc4" id="9dc4" class="graf graf--blockquote graf-after--blockquote"><code class="markup--code markup--blockquote-code"><strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">newtype</em></strong></code>‚Ää‚Äî‚Ääintroduces a renaming of a type and requires you to provide new constructors</blockquote><h4 name="089e" id="089e" class="graf graf--h4 graf-after--blockquote">Type</h4><p name="3c8d" id="3c8d" class="graf graf--p graf-after--h4">As the definition says, it‚Äôs just a synonym for a type. Let‚Äôs say you are creating a program for printing remarks of students performance with respect to their marks, it‚Äôs intuitive to call marks as <code class="markup--code markup--p-code">Marks</code> instead of <code class="markup--code markup--p-code">Int</code></p><pre name="e0a7" id="e0a7" class="graf graf--pre graf-after--p">type Marks = Int</pre><pre name="c38f" id="c38f" class="graf graf--pre graf-after--pre">getRemarks :: Marks -&gt; String<br>getRemarks mark = <br>    mark &lt; 25  = &quot;Not my son&quot;<br>    mark &lt;= 50 = &quot;Okay&quot;<br>    mark &lt;= 99 = &quot;You could do better&quot; -- typical Asian parent<br>    otherwise  = &quot;Now you are my son&quot;</pre><p name="e507" id="e507" class="graf graf--p graf-after--pre">and you can call the function with either <code class="markup--code markup--p-code">Marks</code> or an <code class="markup--code markup--p-code">Int</code>, both will work</p><pre name="9b2e" id="9b2e" class="graf graf--pre graf-after--p">&gt;&gt;&gt;  getRemarks (66 :: Marks) <br>&quot;You could do better&quot;</pre><pre name="0dbd" id="0dbd" class="graf graf--pre graf-after--pre">&gt;&gt;&gt; getRemarks (24 :: Int)<br>&quot;Not my son&quot;</pre><p name="360b" id="360b" class="graf graf--p graf-after--pre">If you are coming from C background, it‚Äôs nothing but a <a href="https://www.tutorialspoint.com/cprogramming/c_typedef.htm" data-href="https://www.tutorialspoint.com/cprogramming/c_typedef.htm" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">typedef</a>.</p><p name="258f" id="258f" class="graf graf--p graf-after--p">When the code gets compiled, all the <code class="markup--code markup--p-code">Marks</code> will be replace by Int.</p><p name="d03f" id="d03f" class="graf graf--p graf-after--p">Most frequently people use type synonym for avoiding redundant code and increasing readability.</p><ul class="postList"><li name="36a8" id="36a8" class="graf graf--li graf-after--p">You could give a type synonym to a record which has lot of fields, instead of repeating the whole structure again and again.</li><li name="e735" id="e735" class="graf graf--li graf-after--li">You could give a type synonym to a return type which has complex nested structure. For example, (type <a href="https://pursuit.purescript.org/packages/purescript-foreign/7.0.0/docs/Foreign#t:F" data-href="https://pursuit.purescript.org/packages/purescript-foreign/7.0.0/docs/Foreign#t:F" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">F</a> which is defined in purescript-foreign)</li></ul><pre name="2438" id="2438" class="graf graf--pre graf-after--li">type F = ExceptT MultipleErrors</pre><pre name="ca4f" id="ca4f" class="graf graf--pre graf-after--pre graf--trailing"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0">-- another example<br>type <a href="https://pursuit.purescript.org/packages/purescript-node-fs/8.1.0/docs/Node.FS.Async#t:Callback" data-href="https://pursuit.purescript.org/packages/purescript-node-fs/8.1.0/docs/Node.FS.Async#t:Callback" class="markup--anchor markup--pre-anchor" title="Node.FS.Async.Callback" rel="noopener" target="_blank"><strong class="markup--strong markup--pre-strong">Callback</strong></a> a = <a href="https://pursuit.purescript.org/packages/purescript-either/6.1.0/docs/Data.Either#t:Either" data-href="https://pursuit.purescript.org/packages/purescript-either/6.1.0/docs/Data.Either#t:Either" class="markup--anchor markup--pre-anchor" title="Data.Either.Either" rel="noopener" target="_blank"><strong class="markup--strong markup--pre-strong">Either</strong></a> <a href="https://pursuit.purescript.org/packages/purescript-exceptions/6.0.0/docs/Effect.Exception#t:Error" data-href="https://pursuit.purescript.org/packages/purescript-exceptions/6.0.0/docs/Effect.Exception#t:Error" class="markup--anchor markup--pre-anchor" title="Effect.Exception.Error" rel="noopener" target="_blank"><strong class="markup--strong markup--pre-strong">Error</strong></a> a -&gt; <a href="https://pursuit.purescript.org/packages/purescript-effect/4.0.0/docs/Effect#t:Effect" data-href="https://pursuit.purescript.org/packages/purescript-effect/4.0.0/docs/Effect#t:Effect" class="markup--anchor markup--pre-anchor" title="Effect.Effect" rel="noopener" target="_blank"><strong class="markup--strong markup--pre-strong">Effect</strong></a> <a href="https://pursuit.purescript.org/packages/purescript-prelude/6.0.0/docs/Data.Unit#t:Unit" data-href="https://pursuit.purescript.org/packages/purescript-prelude/6.0.0/docs/Data.Unit#t:Unit" class="markup--anchor markup--pre-anchor" title="Data.Unit.Unit" rel="noopener" target="_blank"><strong class="markup--strong markup--pre-strong">Unit</strong></a></code></pre></div></div></section><section name="59cb" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h4 name="26fb" id="26fb" class="graf graf--h4 graf--leading">Newtype</h4><p name="2466" id="2466" class="graf graf--p graf-after--h4">As the definition says, it renames a type. You can create a new type out of any other type by just wrapping it with a <code class="markup--code markup--p-code">newtype</code> keyword.</p><pre name="f56a" id="f56a" class="graf graf--pre graf-after--p">newtype Marks = Marks Int</pre><p name="ef1c" id="ef1c" class="graf graf--p graf-after--pre">The left and Right side names need not to be the same, the below is also a valid newtype.</p><pre name="c8ea" id="c8ea" class="graf graf--pre graf-after--p">newtype Marks = MkMarks Int</pre><p name="f9c2" id="f9c2" class="graf graf--p graf-after--pre">Here, <code class="markup--code markup--p-code">Marks</code> is the name of the new type and <code class="markup--code markup--p-code">MkMarks</code> is the constructor needed to create the newtype.</p><blockquote name="8b97" id="8b97" class="graf graf--blockquote graf-after--p">Note: <code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">newtype</em></code> can have only one constructor as opposed to <code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">data</em></code> which could have more than one construtor.</blockquote><p name="d0de" id="d0de" class="graf graf--p graf-after--blockquote">If you rewrite the above function with the newtype,</p><pre name="732c" id="732c" class="graf graf--pre graf-after--p">getRemarks :: Marks -&gt; String<br>getRemarks (MkMarks mark) = <br>    --- same code</pre><blockquote name="354b" id="354b" class="graf graf--blockquote graf-after--pre">Note: To access the inner type, you have to unwrap it.</blockquote><p name="56c5" id="56c5" class="graf graf--p graf-after--blockquote">You can call the above function only with <code class="markup--code markup--p-code">Marks</code> not with Int</p><pre name="ed6f" id="ed6f" class="graf graf--pre graf-after--p">&gt;&gt;&gt; getRemarks (MkMarks 66)<br>&quot;You could do better&quot;</pre><pre name="ae0b" id="ae0b" class="graf graf--pre graf-after--pre">&gt;&gt;&gt; getRemarks 24<br>-- throws error</pre><p name="1d5f" id="1d5f" class="graf graf--p graf-after--pre">you will get the following error,</p><pre name="bed0" id="bed0" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">Could not match type</code></pre><pre name="9601" id="9601" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">    Int</code></pre><pre name="1848" id="1848" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  with type</code></pre><pre name="743a" id="743a" class="graf graf--pre graf-after--pre graf--trailing"><code class="markup--code markup--pre-code">    Marks</code></pre></div></div></section><section name="0ac6" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h4 name="5e0e" id="5e0e" class="graf graf--h4 graf--leading"><strong class="markup--strong markup--h4-strong">The power of¬†newtypes</strong></h4><p name="3280" id="3280" class="graf graf--p graf-after--h4">You may ask, ‚ÄúBoth of them serves the same purpose, they let us rename the types and for newtype we just have to do the additional step of wrapping and unwrapping, where and why exactly should we prefer the one over the other? Does new type has any use?‚Äù</p><p name="b27a" id="b27a" class="graf graf--p graf-after--p">Let me tell you two beneficial ways in which we can use newtypes,</p><h4 name="3162" id="3162" class="graf graf--h4 graf-after--p">1. <a href="https://wiki.haskell.org/Smart_constructors" data-href="https://wiki.haskell.org/Smart_constructors" class="markup--anchor markup--h4-anchor" rel="noopener" target="_blank">Smart Constructor</a></h4><p name="6723" id="6723" class="graf graf--p graf-after--h4">First let‚Äôs consider a scenario,</p><p name="e400" id="e400" class="graf graf--p graf-after--p">You want to create a Password type, and your requirement is it should have at least 6 characters. How can you do that?</p><pre name="4dee" id="4dee" class="graf graf--pre graf-after--p">type Password = String</pre><pre name="a5a5" id="a5a5" class="graf graf--pre graf-after--pre">type RegisterDetails = <br>     { email :: String <br>     , password :: Password<br>     }</pre><pre name="d51a" id="d51a" class="graf graf--pre graf-after--pre">createPassword :: Password -&gt; Either String Password<br>createPassword password = if length password &gt;= 6 <br>                               then Right password<br>                               else Left &quot;Size should be atleast 6&quot;</pre><p name="a42e" id="a42e" class="graf graf--p graf-after--pre">and we tell the developers that they should always create a password by calling the createPassword function.</p><pre name="5aab" id="5aab" class="graf graf--pre graf-after--p">registerUser :: String -&gt; Password -&gt; Either String RegisterDetails<br>registerUser email password = <br>  case createPassword password of <br>     Right validPassword -&gt; Right {email, password : validPassword}<br>     Left err -&gt; Left err</pre><p name="5106" id="5106" class="graf graf--p graf-after--pre">But what prevent them from doingüòà,</p><pre name="2d7c" id="2d7c" class="graf graf--pre graf-after--p">myNewRegisteredUser :: RegisterDetails<br>myNewRegisteredUser = {email : &quot;hacker@gmail.com&quot;, password: &quot;haha&quot;}</pre><p name="9b77" id="9b77" class="graf graf--p graf-after--pre">Since password is just a type synonym of plain String, the type system will let us create it as long as it is a string. So how can we restrict the user/developer from creating their own password? The answer is smart constructors.</p><blockquote name="a39e" id="a39e" class="graf graf--blockquote graf-after--p">Sometimes you need guarantees about the values in your program beyond what can be accomplished with the usual <a href="https://wiki.haskell.org/Type" data-href="https://wiki.haskell.org/Type" class="markup--anchor markup--blockquote-anchor" title="Type" rel="noopener" target="_blank">type system</a> checks. Smart constructors can be used for this purpose.</blockquote><p name="4349" id="4349" class="graf graf--p graf-after--blockquote">Instead of keeping Password as type, let‚Äôs change it to newtype</p><pre name="819e" id="819e" class="graf graf--pre graf-after--p">newtype Password = MkPassword String</pre><figure name="63b8" id="63b8" class="graf graf--figure graf--iframe graf-after--pre"><script src="https://gist.github.com/imsaravana369/0499788b7df032c174139360bbe06fa1.js"></script></figure><p name="4a61" id="4a61" class="graf graf--p graf-after--figure">If you look at the above code, createPassword is called the smart constructor. Smart constructors are nothing but functions that let us create the required type but with some additional value level checks.</p><p name="51b7" id="51b7" class="graf graf--p graf-after--p">You may still ask, what prevents us from doing,</p><pre name="3ab6" id="3ab6" class="graf graf--pre graf-after--p">myNewRegisteredUser :: RegisterDetails<br>myNewRegisteredUser = <br>    { email : &quot;hacker@gmail.com&quot;<br>    , password: MKPassword &quot;a&quot;}</pre><p name="99a0" id="99a0" class="graf graf--p graf-after--pre">Actually we can still do thatüòÖ‚Ä¶</p><p name="efc3" id="efc3" class="graf graf--p graf-after--p">Whattt¬†??</p><p name="9c13" id="9c13" class="graf graf--p graf-after--p">The last important thing that we should is, we should not expose the constructor(<code class="markup--code markup--p-code">MkPassword</code> ) of Password‚Ä¶ How can we do that..?</p><p name="42f8" id="42f8" class="graf graf--p graf-after--p">We could do that by only importing the<code class="markup--code markup--p-code">Password</code>type not along with its constructor <code class="markup--code markup--p-code">MkPassword</code></p><pre name="5470" id="5470" class="graf graf--pre graf-after--p">module MyRegisterModule<br>  ( Password  -- not Password(..)<br>  , ...<br>  ) where </pre><pre name="d9ab" id="d9ab" class="graf graf--pre graf-after--pre">// the code</pre><p name="9744" id="9744" class="graf graf--p graf-after--pre">If you skip <code class="markup--code markup--p-code">(..)</code> it only imports the type, now people can‚Äôt use <code class="markup--code markup--p-code">MkPassword</code> outside your module</p><pre name="e0e1" id="e0e1" class="graf graf--pre graf-after--p">&gt;&gt;&gt; MKPassword &quot;a&quot;<br><code class="markup--code markup--pre-code">Unknown data constructor &quot;</code>MKPassword&quot;</pre><p name="dbac" id="dbac" class="graf graf--p graf-after--pre">You have prevented people from creating password and added logic for creating the type (should be at least of size 6).</p><p name="c696" id="c696" class="graf graf--p graf-after--p">With the help of the Smart constructors, we can have some guarantees about the values in your program beyond what can be accomplished with the usual <a href="https://wiki.haskell.org/Type" data-href="https://wiki.haskell.org/Type" class="markup--anchor markup--p-anchor" title="Type" rel="noopener" target="_blank">type system</a> checks.</p><p name="75f8" id="75f8" class="graf graf--p graf-after--p">E.g Beside Knowing that our password will be of type <code class="markup--code markup--p-code">String</code> (type level guarantee) which is ensured by our type system, we could also assure now that our password will at least be of size 6 (value level guarantee)</p><h4 name="192d" id="192d" class="graf graf--h4 graf-after--p">2.Create our own instance for type¬†classes</h4><p name="63c6" id="63c6" class="graf graf--p graf-after--h4">Type classes are like interfaces, they only have the method signature but not definition. Each type define their own instance for the type class they want to implement. E.g <code class="markup--code markup--p-code">Show</code> is a type class which has a method called <code class="markup--code markup--p-code">show</code></p><p name="c3fc" id="c3fc" class="graf graf--p graf-after--p">We can derive instances for newtype by using,</p><pre name="1cf3" id="1cf3" class="graf graf--pre graf-after--p">derive newtype instance showPassword :: Show Password</pre><p name="8279" id="8279" class="graf graf--p graf-after--pre">which will derive the instance with respect to the type it wraps, in this case Password will have the show instance of string.</p><p name="cecc" id="cecc" class="graf graf--p graf-after--p">But we don‚Äôt want to show our password to anyone, how could we do that?</p><pre name="83c2" id="83c2" class="graf graf--pre graf-after--p">import Data.String.Utils as StringUtils<br>import Data.String.Common(joinWith)</pre><pre name="2101" id="2101" class="graf graf--pre graf-after--pre">instance showPassword :: Show Password  where<br>  show (MkPassword p) <br>              = joinWith &quot;&quot; <br>              $ map (const &quot;*&quot;) <br>              $ StringUtils.toCharArray p</pre><p name="e217" id="e217" class="graf graf--p graf-after--pre">Now if we call show method on Password we will get password masked with asterisk,</p><pre name="6d08" id="6d08" class="graf graf--pre graf-after--p">&gt;&gt;&gt; show password -- assume (password = MkPassword &quot;hello123&quot;)<br>&gt;&gt;&gt; ******</pre><p name="f531" id="f531" class="graf graf--p graf-after--pre graf--trailing">When you want to override the type class instances of already defined types, you have to wrap that type with <code class="markup--code markup--p-code">newtype</code> and then you can define new instances for any type class you wish to override.</p></div></div></section><section name="a253" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h4 name="bba3" id="bba3" class="graf graf--h4 graf--leading">When Should you prefer the one over the¬†other?</h4><ul class="postList"><li name="df4c" id="df4c" class="graf graf--li graf-after--h4">When your only intention is to make the code readable and less redundant, use <code class="markup--code markup--li-code">type</code> but if you want to make the type behave differently (type class instances) then go for <code class="markup--code markup--li-code">newtype</code>.</li><li name="4eae" id="4eae" class="graf graf--li graf-after--li graf--trailing">If you want to add restriction on <strong class="markup--strong markup--li-strong">value level</strong>, create smart constructor using newtypes. When you think, type level checks are enough go with type synonym.</li></ul></div></div></section><section name="d387" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="a5ab" id="a5ab" class="graf graf--p graf--leading">Hope you have learnt the differences between type and newtype, and when you should prefer the one over the other.</p><p name="2d59" id="2d59" class="graf graf--p graf-after--p graf--trailing">Share it with your friends and colleagues, and Clap<strong class="markup--strong markup--p-strong">üëè </strong>if you‚Äôve liked this article.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@imsaravananm" class="p-author h-card">Saravanan M</a> on <a href="https://medium.com/p/ce4783e00e7a"><time class="dt-published" datetime="2022-10-19T14:09:50.992Z">October 19, 2022</time></a>.</p><p><a href="https://medium.com/@imsaravananm/type-vs-new-type-when-you-should-prefer-the-one-over-the-other-ce4783e00e7a" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 7, 2023.</p></footer></article></body></html>