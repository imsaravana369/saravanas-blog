<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Let’s play with Heterogeneous data types — purescript-heterogeneous</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Let’s play with Heterogeneous data types — purescript-heterogeneous</h1>
</header>
<section data-field="subtitle" class="p-summary">
Let’s do some cool stuff with records using purescript-heterogeneous package.
</section>
<section data-field="body" class="e-content">
<section name="9536" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="4ca4" id="4ca4" class="graf graf--h3 graf--leading graf--title">Let’s play with Heterogeneous data types — purescript-heterogeneous — Exploring purescript-modules #2</h3><p name="d412" id="d412" class="graf graf--p graf-after--h3">This is the second article in the series <code class="markup--code markup--p-code">#exploring-ps-modules</code>. In this article, we are going to look into the <code class="markup--code markup--p-code">purescript-heterogeneous</code>package which is exclusively developed for mapping and folding over heterogeneous data structure. Okay what do I mean by heterogeneous data structure here?</p><p name="8e48" id="8e48" class="graf graf--p graf-after--p">All the types that can hold more that one value at a time is called heterogeneous data structure, or types. Example, Tuples can hold more than one value at a time, a left and right value. So they are called heterogeneous data types. But Arrays aren’t heterogeneous as all the elements can be of one type only.</p><figure name="ee55" id="ee55" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*6fOIDby58VpuhKTlhJKdGw.jpeg" data-width="1920" data-height="1280" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*6fOIDby58VpuhKTlhJKdGw.jpeg"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@sharonmccutcheon?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" data-href="https://unsplash.com/@sharonmccutcheon?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Alexander Grey</a> on <a href="https://unsplash.com/s/photos/different-colors?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" data-href="https://unsplash.com/s/photos/different-colors?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><p name="bc5d" id="bc5d" class="graf graf--p graf-after--figure">The most common heterogeneous type we deal with in purescript is Record. I always wondered how can we map over Records, then I came across this wonderful package <code class="markup--code markup--p-code"><a href="https://pursuit.purescript.org/packages/purescript-heterogeneous/0.3.0" data-href="https://pursuit.purescript.org/packages/purescript-heterogeneous/0.3.0" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">purescript-heterogeneous</a></code></p><p name="4e8b" id="4e8b" class="graf graf--p graf-after--p">First, lets suppose all the fields in your record is Homogeneous (same type)</p><pre name="c4a3" id="c4a3" class="graf graf--pre graf-after--p">type Names = <br>  {  father     :: String<br>  ,  mother     :: String<br>  ,  son        :: String<br>  ,  daughter   :: String<br>  }</pre><p name="4bc7" id="4bc7" class="graf graf--p graf-after--pre">and you want to uppercase each and every fields, can you do that with normal <code class="markup--code markup--p-code">map</code> ? Hell no, why? Because record isn’t a <a href="https://pursuit.purescript.org/packages/purescript-prelude/6.0.1/docs/Data.Functor#t:Functor" data-href="https://pursuit.purescript.org/packages/purescript-prelude/6.0.1/docs/Data.Functor#t:Functor" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Functor</a>.</p><p name="2adf" id="2adf" class="graf graf--p graf-after--p">So how can we do that?</p><pre name="31d2" id="31d2" class="graf graf--pre graf-after--p">capitalizeNames :: Names -&gt; Names <br>capitalizeNames names = hmap toUpper names</pre><p name="8e33" id="8e33" class="graf graf--p graf-after--pre graf--trailing">Look closely, I haven’t used <code class="markup--code markup--p-code">map</code> I have used <code class="markup--code markup--p-code">hmap</code> which is provided by the package <code class="markup--code markup--p-code">purescript-heterogeneous.</code></p></div></div></section><section name="0b95" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="071f" id="071f" class="graf graf--p graf--leading">I have come across a situation where I have a record and I just wanted to add <code class="markup--code markup--p-code">Just</code>to each and every value in the record. I wondered how could I do that? can we do something like the above?</p><pre name="b717" id="b717" class="graf graf--pre graf-after--p">justRecords names = hmap Just names -- will throw error</pre><p name="e647" id="e647" class="graf graf--p graf-after--pre">No we can’t, why? Because each and every field could be of different types, so whats the type of <code class="markup--code markup--p-code">Just</code> would be? <code class="markup--code markup--p-code">String -&gt; Maybe String</code> , or <code class="markup--code markup--p-code">Int -&gt; Maybe Int</code> etc… It should be ideally <code class="markup--code markup--p-code">a -&gt; Maybe a</code></p><p name="12a3" id="12a3" class="graf graf--p graf-after--p">To encapsulate the <code class="markup--code markup--p-code">a</code> we need to create a type, (don’t worry its damn simple)</p><p name="af80" id="af80" class="graf graf--p graf-after--p">First create a type,</p><pre name="b207" id="b207" class="graf graf--pre graf-after--p">data MakeMaybe = MakeMaybe</pre><p name="f683" id="f683" class="graf graf--p graf-after--pre">then derive an instance for the <code class="markup--code markup--p-code">Mapping</code> class defined in the heterogeneous package.</p><pre name="b331" id="b331" class="graf graf--pre graf-after--p">instance makeMaybeMapping :: Mapping MakeMaybe a (Maybe a) <br> where<br>     mapping MakeMaybe = Just</pre><p name="bd3a" id="bd3a" class="graf graf--p graf-after--pre">Mapping type class takes 3 arguments, the first one is the Monomorphic type that you have created, the second and third one are <code class="markup--code markup--p-code">a</code> and <code class="markup--code markup--p-code">b</code> in the mapping function <code class="markup--code markup--p-code">(a -&gt; b).</code> In our case, it is <code class="markup--code markup--p-code">a -&gt; Maybe a</code></p><p name="8ac7" id="8ac7" class="graf graf--p graf-after--p">In the above code, I’m telling to convert the type <code class="markup--code markup--p-code">a</code> to <code class="markup--code markup--p-code">Maybe a</code> using <code class="markup--code markup--p-code">Just</code> , you could also put <code class="markup--code markup--p-code">Nothing</code> in place of <code class="markup--code markup--p-code">Just</code> which will convert every fields to <code class="markup--code markup--p-code">Nothing</code> (But who would want such a function?😑)</p><p name="3d75" id="3d75" class="graf graf--p graf-after--p">and using it is also very easy, you just <code class="markup--code markup--p-code">hmap</code> with that type that you’ve created.</p><pre name="c41f" id="c41f" class="graf graf--pre graf-after--p">makeMaybe names = hmap MakeMaybe names</pre><p name="a5db" id="a5db" class="graf graf--p graf-after--pre">The type signature of makeMaybe will look something like,</p><pre name="e7bb" id="e7bb" class="graf graf--pre graf-after--p">type MaybeNames = {  father     :: Maybe String<br>                  ,  mother     :: Maybe String<br>                  ,  son        :: Maybe String<br>                  ,  daughter   :: Maybe String<br>                  }</pre><pre name="42eb" id="42eb" class="graf graf--pre graf-after--pre">makeMaybe :: Names -&gt; MaybeNames <br>makeMaybe = ....</pre><blockquote name="dedc" id="dedc" class="graf graf--blockquote graf-after--pre">Note: In the above example, fields could be of any type, until they are wrapped with Maybe.</blockquote><p name="20db" id="20db" class="graf graf--p graf-after--blockquote">See, <code class="markup--code markup--p-code">hmap</code>has transformed our record type into completely new type. They are lot of things that we can do with <code class="markup--code markup--p-code">hmap</code>, for instance if you want to convert all the field type to string, you can do something like</p><pre name="d483" id="d483" class="graf graf--pre graf-after--p">--- create a type<br>data MakeString = MakeString</pre><pre name="9139" id="9139" class="graf graf--pre graf-after--pre">--- create the Mapping instance <br>instance makeMakeString :: (Show a) =&gt; Mapping MakeString a String<br>  where<br>     mapping MakeString = show</pre><pre name="d4dd" id="d4dd" class="graf graf--pre graf-after--pre">--- create a method that does the mapping<br>makeString names = hmap MakeString names</pre><p name="9d3b" id="9d3b" class="graf graf--p graf-after--pre">So easy, isn’t it?</p><p name="50a1" id="50a1" class="graf graf--p graf-after--p">But what if you can’t unify the types like above (by using constraints like <code class="markup--code markup--p-code">Show</code> saying that all fields have show instance or by blindly using the universal quantifier like <code class="markup--code markup--p-code">forall a</code>) ?</p><p name="b43d" id="b43d" class="graf graf--p graf-after--p">What if you want to have a separate mapping function for each and every fields? can we do that with this package? Yes my friend !!</p><p name="ecf8" id="ecf8" class="graf graf--p graf-after--p">But you have write some boiler plate while creating the instance, but be with me it’s so simple &amp; you will get used to it very quickly.</p><p name="992c" id="992c" class="graf graf--p graf-after--p">First, as usual let’s create a data type which wraps a record (of functions in this case).</p><pre name="e757" id="e757" class="graf graf--pre graf-after--p">data ZipProps fns = ZipProps { | fns}</pre><p name="8fa3" id="8fa3" class="graf graf--p graf-after--pre">Previously we were creating <code class="markup--code markup--p-code">Mapping</code> typeclass instance, but in this case we are going to use <code class="markup--code markup--p-code">MappingWithIndex</code> which gives us field name via <code class="markup--code markup--p-code">Proxy</code></p><pre name="1bd7" id="1bd7" class="graf graf--pre graf-after--p">instance zipProps ::<br>  (IsSymbol sym, Row.Cons sym (a -&gt; b) tail fns) =&gt;<br>  MappingWithIndex (ZipProps fns) (Proxy sym) a b where<br>  mappingWithIndex (ZipProps fns) prop = Record.get prop fns</pre><p name="fa8b" id="fa8b" class="graf graf--p graf-after--pre">Okay, this might be confusing, let me dissect it</p><p name="6dda" id="6dda" class="graf graf--p graf-after--p">MapWithIndex takes 4 parameter</p><ol class="postList"><li name="c033" id="c033" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">ZipProps fns</code>— The Datatype that you have created, in our case its ZipProps which wraps the record of functions.</li><li name="9331" id="9331" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">Proxy sym</code> — This gives us the name of the field.</li><li name="15e2" id="15e2" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">a</code> — The type of the field</li><li name="a4d5" id="a4d5" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">b</code> — The type of the field after transforming it with the function.</li></ol><pre name="9595" id="9595" class="graf graf--pre graf-after--li">IsSymbol sym, Row.Cons sym (a -&gt; b) tail fns</pre><p name="5616" id="5616" class="graf graf--p graf-after--pre">Now let’s look at the constraints,</p><ol class="postList"><li name="b637" id="b637" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">IsSymbol sym</code> — Indicates that the <code class="markup--code markup--li-code">sym</code> in the proxy is a symbol(S<a href="https://pursuit.purescript.org/packages/purescript-prelude/6.0.1/docs/Data.Symbol" data-href="https://pursuit.purescript.org/packages/purescript-prelude/6.0.1/docs/Data.Symbol" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">ymbols</a> are just type level strings, you could use <code class="markup--code markup--li-code">reflectSymbol</code> to convert Symbols to Strings)</li><li name="979f" id="979f" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">Row.Cons sym (a -&gt; b) tail fns</code> — This constraint is telling field name <code class="markup--code markup--li-code">sym</code> has the type <code class="markup--code markup--li-code">a-&gt;b</code> (a function from a to b) along with the remaining rows <code class="markup--code markup--li-code">tail</code> will make the whole record <code class="markup--code markup--li-code">fns</code> . It translates to something like the below block</li></ol><pre name="50f6" id="50f6" class="graf graf--pre graf-after--li">fns = { sym :: (a -&gt; b)<br>      , ... tail <br>      }</pre><p name="8b7d" id="8b7d" class="graf graf--p graf-after--pre">Now let’s look at what the definition mean,</p><pre name="904f" id="904f" class="graf graf--pre graf-after--p">mappingWithIndex (ZipProps fns) prop = Record.get prop fns</pre><p name="2a6f" id="2a6f" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">Record.get</code> takes two parameters, a proxy which has the field name as symbol and the actual record and give the value back. Its like accessing</p><pre name="0446" id="0446" class="graf graf--pre graf-after--p">fns.prop -- where fns is an object and prop is the field name</pre><p name="70b3" id="70b3" class="graf graf--p graf-after--pre graf--trailing">The above line will return a function that goes from <code class="markup--code markup--p-code">a -&gt; b</code> where the type of the corresponding field with the same name is <code class="markup--code markup--p-code">a</code> . Example if the <code class="markup--code markup--p-code">father</code> field is of type <code class="markup--code markup--p-code">String</code> , then <code class="markup--code markup--p-code">father</code> field in fns is a function that goes from <code class="markup--code markup--p-code">String -&gt; sometype</code> (it must take the same type as the argument)</p></div></div></section><section name="8745" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="7fb5" id="7fb5" class="graf graf--p graf--leading">Now let’s create a zipping function, that takes record of function and apply them to record of the elements with the same field name.</p><pre name="e93d" id="e93d" class="graf graf--pre graf-after--p">--- the zipping function<br>zipRecord fns record = hmapWithIndex (ZipProps fns) record</pre><pre name="70e0" id="70e0" class="graf graf--pre graf-after--pre">--- the mapping function <br>fns =  { aNumber :  \num  -&gt; num + 1<br>       , aString. : \str  -&gt; str &lt;&gt; &quot;!!&quot;<br>       , aBool    : \bool -&gt; not bool <br>       }</pre><pre name="adbc" id="adbc" class="graf graf--pre graf-after--pre">--- the record to be transformed<br>num = { aNumber : 2 <br>      , aString:&quot;Hello&quot;<br>      , aBool : false }</pre><pre name="aa3c" id="aa3c" class="graf graf--pre graf-after--pre">&gt;&gt;&gt; zipRecord fns num<br>{ aNumber: 3, aString: &quot;Hello!!&quot;, aBool: true }</pre><blockquote name="9472" id="9472" class="graf graf--blockquote graf--hasDropCapModel graf-after--pre">Note : The field names should match each other</blockquote><p name="8e1d" id="8e1d" class="graf graf--p graf-after--blockquote">The heterogeneous package also provides a way to fold record but we are not going to look at it in this article that would be a topic of other day.</p><p name="6652" id="6652" class="graf graf--p graf-after--p graf--trailing">I hope you learnt some cool stuff and got to know how cool😎 the heterogeneous package is, which can make working with record super flexible and easy.</p></div></div></section><section name="3177" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="3058" id="3058" class="graf graf--p graf--leading graf--trailing">Will see you in the next article with some other cool package. Clap👏 if you’ve liked this article and share it with your friends if you find this article helpful.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@imsaravananm" class="p-author h-card">Saravanan M</a> on <a href="https://medium.com/p/847391430d00"><time class="dt-published" datetime="2022-09-24T15:28:13.785Z">September 24, 2022</time></a>.</p><p><a href="https://medium.com/@imsaravananm/lets-play-with-heterogeneous-data-types-purescript-heterogeneous-847391430d00" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 7, 2023.</p></footer></article></body></html>