<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Statically Typed vs Strongly Typed</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Statically Typed vs Strongly Typed</h1>
</header>
<section data-field="subtitle" class="p-summary">
They both are about strict type checks, but arenâ€™t same.
</section>
<section data-field="body" class="e-content">
<section name="f567" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="5cff" id="5cff" class="graf graf--h3 graf--leading graf--title">Statically Typed vs StronglyÂ Typed</h3><p name="6e2b" id="6e2b" class="graf graf--p graf-after--h3">Static typing and strongly typed concepts have been one of the most perplexing topics Iâ€™ve encountered. While they seem clear individually, Iâ€™ve often struggled to distinguish them from each other, questioning how one can exist without the other. Though I occasionally still grapple with these thoughts, Iâ€™ll try to share my understanding in this article.</p><figure name="c9a1" id="c9a1" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*tTz39aOJzUMVzfcrndoeOw.jpeg" data-width="4096" data-height="3072" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*tTz39aOJzUMVzfcrndoeOw.jpeg"><figcaption class="imageCaption">Statically Typed vs StronglyÂ Typed</figcaption></figure><p name="c949" id="c949" class="graf graf--p graf-after--figure">Before comparing these two distinct jargons, letâ€™s begin by briefly comparing each of them with their respective counterparts</p><p name="1d50" id="1d50" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Statically Typed vs Dynamically Typed</strong></p><p name="9ce2" id="9ce2" class="graf graf--p graf-after--p">They define <strong class="markup--strong markup--p-strong">when the</strong> <strong class="markup--strong markup--p-strong">type-check happens</strong>.</p><p name="a861" id="a861" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Statically typed</strong>Â : In a statically typed language, every variable and function must be <strong class="markup--strong markup--p-strong">explicitly</strong> <strong class="markup--strong markup--p-strong">annotated with a fixed type signature</strong> by the programmer. This crucial step enables the compiler to determine and validate all the data types during the compilation process.</p><p name="e3e7" id="e3e7" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Dynamically Typed</strong>: In a dynamically typed language, types are only resolved at runtime based on the values they hold during program execution. As a result, the compiler completely disregards type-checking during the compilation process.</p><p name="2791" id="2791" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Thought Experiment</strong>: Letâ€™s say you have a function, it has a if-else branch, inside the <code class="markup--code markup--p-code">if</code> you are returning an <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">int</strong></code> and within <code class="markup--code markup--p-code">else</code> youâ€™re returning a string.</p><ul class="postList"><li name="7c8b" id="7c8b" class="graf graf--li graf-after--p">What would be the return type of your function, string or int?</li><li name="f118" id="f118" class="graf graf--li graf-after--li">Which of the above typing allows the behavior?</li><li name="c722" id="c722" class="graf graf--li graf-after--li graf--trailing">Can you have overloaded functions on dynamically typed languages?</li></ul></div></div></section><section name="4aa3" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h4 name="0e6f" id="0e6f" class="graf graf--h4 graf--leading">Strongly Typed vs WeaklyÂ Typed</h4><p name="56ef" id="56ef" class="graf graf--p graf-after--h4">This topic is quite opinionated and lacks a universally fixed definition on its own.</p><p name="9c5f" id="9c5f" class="graf graf--p graf-after--p">However, many people agree on the following definition,</p><p name="d799" id="d799" class="graf graf--p graf-after--p">The S<em class="markup--em markup--p-em">trongly/Weakly</em> typed nature of a language concerns the implicit type casting performed by the language or, the <strong class="markup--strong markup--p-strong">degree of flexibility the language exhibits in converting one data type to another</strong>.</p><p name="a764" id="a764" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Weakly TypedÂ : </strong>Think of weakly typed languages as individuals who are extremely agreeable. When you attempt to perform operations with completely different data types, they readily handle implicit type conversion on your behalf (Doing all sort of things to keep the party going)</p><p name="c8ad" id="c8ad" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Strongly TypedÂ : </strong>On the other hand, strongly typed languages are the complete opposite. They do not compromise when it comes to type rules. If you want to add a string with an int, then you have do it explicitly. (No implicit coercion of types) and you cannot randomly cast any type to any other type, there are rules, strict rules.</p><p name="6dc2" id="6dc2" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Thought Experiment</strong>:</p><p name="cb09" id="cb09" class="graf graf--p graf-after--p">Letâ€™s say you are trying to add a String with an Int</p><ul class="postList"><li name="7866" id="7866" class="graf graf--li graf-after--p">Should I convert the <code class="markup--code markup--li-code">Int</code> to <code class="markup--code markup--li-code">String</code> and do string concatenation or,</li><li name="79d7" id="79d7" class="graf graf--li graf-after--li">Should I convert the <code class="markup--code markup--li-code">String</code> to <code class="markup--code markup--li-code">Int</code> and do arithmetic addition?</li></ul><p name="0db2" id="0db2" class="graf graf--p graf-after--li">This completely depends on the language, Thatâ€™s why implicit conversions are more susceptible to unexpected behaviors. Look at javascriptðŸ˜‚</p><h3 name="9665" id="9665" class="graf graf--h3 graf-after--p">Now the realÂ question</h3><p name="ad58" id="ad58" class="graf graf--p graf-after--h3">So now coming back to the actual question, whatâ€™s the difference between statically and strongly typed languages?</p><p name="31a1" id="31a1" class="graf graf--p graf-after--p">From the above comparison, I can already tell a very crucial difference</p><blockquote name="7090" id="7090" class="graf graf--pullquote graf-after--p">Statically typed languages focus on resolving type information of all the expressions at compileÂ time,</blockquote><blockquote name="27eb" id="27eb" class="graf graf--pullquote graf-after--pullquote">Strongly typed languages prevents implicit type conversion and enforce strict rules for explicit typeÂ casting.</blockquote><p name="45f0" id="45f0" class="graf graf--p graf-after--pullquote">I guess the distinction will be much clearer once we look at some snippets where I will be comparing languages that are,</p><ol class="postList"><li name="d2d1" id="d2d1" class="graf graf--li graf-after--p">Statically typed but weakly typed (C language)</li><li name="bc96" id="bc96" class="graf graf--li graf-after--li">Dynamically typed but strongly typed (Python)</li></ol><h4 name="5f36" id="5f36" class="graf graf--h4 graf-after--li">1. Statically and Weakly typedâ€Šâ€”â€ŠC,Â C++</h4><p name="ee34" id="ee34" class="graf graf--p graf-after--h4">In order to define a variable/function we have to declare its type signature first, thatâ€™s what makes a language statically typed.</p><p name="5172" id="5172" class="graf graf--p graf-after--p">But how can a language be weakly typed if it has types predefined?Â <br>Take a look at this example,</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="c" name="6369" id="6369" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-type">int</span> <span class="hljs-title function_">add_one</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>{<br />    <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span>;<br />}<br /><br /><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br />    <span class="hljs-type">int</span> res1 = add_one(<span class="hljs-string">&#x27;a&#x27;</span>);<br />    <span class="hljs-type">int</span> res2 = add_one(<span class="hljs-number">97</span>);<br />    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, res1, res2); <span class="hljs-comment">// 98 98</span><br />    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br />}</span></pre><p name="760c" id="760c" class="graf graf--p graf-after--pre">Even though our function <code class="markup--code markup--p-code">add_one</code> is telling explicitly(statically) that it wants a <code class="markup--code markup--p-code">int</code> we are still able to pass a <code class="markup--code markup--p-code">char</code> (â€˜aâ€™) and get our function to work.</p><p name="10e4" id="10e4" class="graf graf--p graf-after--p">The reason behind this behavior lies in Câ€™s weakly typed nature, where it implicitly converts the character â€˜aâ€™ to its ASCII representation of 97.</p><p name="677b" id="677b" class="graf graf--p graf-after--p">In a weakly typed language, I can write the below code without getting any errors,</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="dart" name="e111" id="e111" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> = <span class="hljs-number">42</span>;<br />float pi = <span class="hljs-number">3.14</span>;<br />        <br /><span class="hljs-comment">// Implicit conversion: int to float</span><br /><span class="hljs-built_in">num</span> = pi;</span></pre><p name="d4f6" id="d4f6" class="graf graf--p graf-after--pre">Consider Java, which is statically and strongly(mostly) typed language, if I try to do the same it will throw error.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="java" name="b15b" id="b15b" class="graf graf--pre graf-after--p graf--trailing graf--preV2"><span class="pre--content"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">42</span>;<br /><span class="hljs-type">double</span> <span class="hljs-variable">pi</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.14</span>;<br />      <br /><span class="hljs-comment">// error: incompatible types: possible lossy conversion from double to int</span><br />num = pi;</span></pre></div></div></section><section name="bac7" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="521e" id="521e" class="graf graf--p graf--leading"><strong class="markup--strong markup--p-strong">2. Dynamically and Strongly typedâ€Šâ€”â€ŠPython</strong></p><p name="798d" id="798d" class="graf graf--p graf-after--p">In Dynamically typed languages, thereâ€™s no type checks done by compiler.</p><p name="9f15" id="9f15" class="graf graf--p graf-after--p">The strongly typed nature make sure no implicit type conversion happens behind the scenes and there are strict type rules on every operation.</p><p name="3a58" id="3a58" class="graf graf--p graf-after--p">Letâ€™s see what I mean by that with an example,</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="27a9" id="27a9" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_one</span>(<span class="hljs-params">num</span>):<br />    <span class="hljs-keyword">return</span> num + <span class="hljs-number">1</span> <br /><br /><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br />    <span class="hljs-comment"># TypeError: can only concatenate str (not &quot;int&quot;) to str</span><br />    res1 = add_one(<span class="hljs-string">&#x27;a&#x27;</span>) <br /><br />    res2 = add_one(<span class="hljs-number">97</span>)<br />    <span class="hljs-built_in">print</span>(res1, res2) </span></pre><p name="eb7f" id="eb7f" class="graf graf--p graf-after--pre">Python being a dynamically typed language doesnâ€™t put any restriction on the type of the argument to <code class="markup--code markup--p-code">add_one</code>Â , <strong class="markup--strong markup--p-strong">However, the validity of operations within the function is determined at runtime based on the type of the argument passed.</strong></p><p name="8055" id="8055" class="graf graf--p graf-after--p">For Example, when passing a character as the argument to <code class="markup--code markup--p-code">add_one</code>, the arithmetic addition with 1 becomes invalid. The strongly typed nature of python doesnâ€™t do implicit conversion like C. If types are not matching, it will throw <code class="markup--code markup--p-code">TypeError</code> at runtime.</p><p name="5195" id="5195" class="graf graf--p graf-after--p">To achieve similar behavior as the above C program, I need to explicitly convert the character to its ASCII representation using <code class="markup--code markup--p-code">ord()</code>.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python-repl" name="fc83" id="fc83" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">add_one(<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>))</span><br />98</span></pre><p name="7d64" id="7d64" class="graf graf--p graf-after--pre graf--trailing">Strongly typed languages enforce strict rules on data types for every operation. Considering the above example, according to python we can concatenate a string with another string, not any other datatypes.</p></div></div></section><section name="ab0e" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h4 name="4eca" id="4eca" class="graf graf--h4 graf--leading">TLDR;</h4><blockquote name="7936" id="7936" class="graf graf--pullquote graf-after--h4">Statically declared types make sure your code type checks at compileÂ time</blockquote><blockquote name="0e01" id="0e01" class="graf graf--pullquote graf-after--pullquote graf--trailing">Strongly typed nature make sure your code also type checks at runtime and the code follows strict typeÂ rules.</blockquote></div></div></section><section name="2f5a" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h4 name="4669" id="4669" class="graf graf--h4 graf--leading">More Thoughts</h4><p name="03e1" id="03e1" class="graf graf--p graf-after--h4 graf--trailing"><strong class="markup--strong markup--p-strong">I used to ponder on this question</strong>Â : Do we truly need strong typing in languages that are both statically and strongly typed? Reflecting on Câ€™s statically but weakly typed nature, where unrestricted type casting still passes code checks, which is quite scary. I concluded that the combination of both static and strong typing provides the best balance for predictable code behavior.</p></div></div></section><section name="5eb8" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="4d93" id="4d93" class="graf graf--p graf--leading">I hope you enjoyed the article and gained a clear understanding of the fundamental difference between statically and strongly typed languages.</p><p name="3730" id="3730" class="graf graf--p graf-after--p graf--trailing">Iâ€™m still learning their difference, If you have any insights or thoughts to share, Iâ€™m all ears and eager to learn from you as well.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@imsaravananm" class="p-author h-card">Saravanan M</a> on <a href="https://medium.com/p/7537b2766c80"><time class="dt-published" datetime="2023-08-05T01:55:29.169Z">August 5, 2023</time></a>.</p><p><a href="https://medium.com/@imsaravananm/statically-typed-vs-strongly-typed-7537b2766c80" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 7, 2023.</p></footer></article></body></html>