<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Unit Testing Streams in Dart/Flutter</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Unit Testing Streams in Dart/Flutter</h1>
</header>
<section data-field="subtitle" class="p-summary">
In this article, I will tell you how we can unit test streams in our app.
</section>
<section data-field="body" class="e-content">
<section name="0398" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="e660" id="e660" class="graf graf--h3 graf--leading graf--title">Unit Testing Streams in Dart/Flutter</h3><p name="5ad4" id="5ad4" class="graf graf--p graf-after--h3">Stream is one of the building blocks of asynchronous programming in dart. We may not deal with them directly most of the time, but they are working under the hood for many features like Bloc,changeNotifier provider, etc. But sometimes we need to create our own streams, so we need to learn how we can unit test streams. That’s what we are going to see in this article.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="ad7f" id="ad7f" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><img class="graf-image" data-image-id="1*THpGvEma6OELd04Haybh_g.jpeg" data-width="2400" data-height="1591" data-is-featured="true" src="https://cdn-images-1.medium.com/max/1200/1*THpGvEma6OELd04Haybh_g.jpeg"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@dynamo10?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" data-href="https://unsplash.com/@dynamo10?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Rahul Dey</a> on <a href="https://unsplash.com/s/photos/streams?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" data-href="https://unsplash.com/s/photos/streams?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="ac98" id="ac98" class="graf graf--p graf-after--figure">Since this article is only about unit testing streams, I will just specify the classes that provide streams service to our app.</p><p name="ed79" id="ed79" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">What does our simple app do?</strong></p><p name="2a76" id="2a76" class="graf graf--p graf-after--p">It will just run the counter either in ascending order or descending order according to the switch we have selected.</p><figure name="4c11" id="4c11" class="graf graf--figure graf--iframe graf-after--p"><iframe src="https://giphy.com/embed/fEv1bACTtco6oPktHE/twitter/iframe" width="435" height="915" frameborder="0" scrolling="no"></iframe></figure><p name="fd37" id="fd37" class="graf graf--p graf-after--figure">Let’s create an interface for our counter</p><h4 name="5a53" id="5a53" class="graf graf--h4 graf-after--p">counter.dart</h4><pre name="7a11" id="7a11" class="graf graf--pre graf-after--h4">abstract class MyCounter{<br>  Stream&lt;int&gt; countStream(int bound);<br>}</pre><p name="a498" id="a498" class="graf graf--p graf-after--pre">This creates a contract that the classes implementing MyCounter will <strong class="markup--strong markup--p-strong">override the countStream() method</strong>.</p><p name="a4c1" id="a4c1" class="graf graf--p graf-after--p">We will be having two implementations for the interface Mycounter</p><p name="76bf" id="76bf" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">1.Forward Counter</strong></p><figure name="f49e" id="f49e" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/imsaravana369/281985e11e5d022b42733ef9ea71fe22.js"></script></figure><p name="0ec7" id="0ec7" class="graf graf--p graf-after--figure">2. Reverse Counter</p><figure name="08fb" id="08fb" class="graf graf--figure graf--iframe graf-after--p graf--trailing"><script src="https://gist.github.com/imsaravana369/d8b1bbf3501029d6e5eadc9d96d51268.js"></script></figure></div></div></section><section name="a5d3" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="5a5d" id="5a5d" class="graf graf--p graf--leading">Now we are done with the setup, let’s write tests</p><h4 name="6b3d" id="6b3d" class="graf graf--h4 graf-after--p">flutter_test Dependency</h4><p name="15f3" id="15f3" class="graf graf--p graf-after--h4">We don’t want to add any extra dependencies by ourselves for unit testing since flutter has it already baked in. Make sure you have <code class="markup--code markup--p-code"><a href="https://api.flutter.dev/flutter/flutter_test/flutter_test-library.html" data-href="https://api.flutter.dev/flutter/flutter_test/flutter_test-library.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">flutter_test </a></code>in your pubspec.yaml <strong class="markup--strong markup--p-strong">under your dev_dependencies.</strong></p><pre name="ce24" id="ce24" class="graf graf--pre graf-after--p">dev_dependencies:<br>  flutter_test:<br>    sdk: flutter<br>  //other dependencies</pre><h4 name="b97d" id="b97d" class="graf graf--h4 graf-after--pre">Create test files</h4><p name="3943" id="3943" class="graf graf--p graf-after--h4">We usually write the test under the <code class="markup--code markup--p-code">test </code>folder, there are some conventions that developers usually follow while writing tests</p><ol class="postList"><li name="2614" id="2614" class="graf graf--li graf-after--p">The structure of your <code class="markup--code markup--li-code">test </code>folder should be as same as your <code class="markup--code markup--li-code">lib</code> folder.</li><li name="72c8" id="72c8" class="graf graf--li graf-after--li">All the tests must end with <code class="markup--code markup--li-code">*_test.dart ,</code>it&#39;s not only a convention, it helps flutter to identify those dart files as tests.</li></ol><p name="8124" id="8124" class="graf graf--p graf-after--li">Let’s test one of our MyCounter implementations <code class="markup--code markup--p-code">reverse_counter.dart </code>and go through them one by one</p><figure name="fd17" id="fd17" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/imsaravana369/d94d131d81118c9193b7b0272bf287fe.js"></script></figure><p name="4798" id="4798" class="graf graf--p graf-after--figure">We have written 4 test cases, let’s go one by one</p><ol class="postList"><li name="cc34" id="cc34" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">emitsInOrder()</strong></li></ol><figure name="9f1a" id="9f1a" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/imsaravana369/d5509a73240ba05fe89468c64d4eef7a.js"></script></figure><blockquote name="b495" id="b495" class="graf graf--pullquote graf-after--figure"><strong class="markup--strong markup--pullquote-strong">emitsInOrder() —</strong> This method makes sure the values are <strong class="markup--strong markup--pullquote-strong">emitted in the exact same order</strong> as we specified.</blockquote><ul class="postList"><li name="f4f8" id="f4f8" class="graf graf--li graf-after--pullquote"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">Why do we use emitsInOrder() in the above code?</em></strong> — we are testing if the values emitted from the stream are <code class="markup--code markup--li-code">3-&gt;2-&gt;1-&gt;0</code> in the decreasing order.</li><li name="04dc" id="04dc" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">How to use it? </em></strong>— The emitsInOrder() takes <code class="markup--code markup--li-code">Iterable matchers </code>as argument. That why we are passing a list of matchers to the method.</li><li name="b48e" id="b48e" class="graf graf--li graf-after--li">We could’ve passed <code class="markup--code markup--li-code">emitsInOrder([ equals(3), equals(2), equals(1),equals(0)] ) </code>but it is not needed since we don’t want to explicitly use <em class="markup--em markup--li-em">equals()</em>.</li><li name="db9a" id="db9a" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">When we use emitsDone?</em></strong> — We use this matcher if we want to verify all the values emitted from the stream are in the exact same order as we specified.</li><li name="f3ae" id="f3ae" class="graf graf--li graf-after--li">If we want to verify all the values are emitted without considering the order, then we can use <strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">emitsInAnyOrder(Iterable Matcher)</em></strong></li></ul><blockquote name="4e7a" id="4e7a" class="graf graf--pullquote graf-after--li"><code class="markup--code markup--pullquote-code"><a href="https://pub.dev/documentation/test_api/latest/test_api/emitsInAnyOrder.html" data-href="https://pub.dev/documentation/test_api/latest/test_api/emitsInAnyOrder.html" class="markup--anchor markup--pullquote-anchor" rel="noopener" target="_blank"><em class="markup--em markup--pullquote-em">emitsInAnyOrder()</em></a></code> works like emitsInOrder(), but it allows the matchers to match in any order.</blockquote><ul class="postList"><li name="f826" id="f826" class="graf graf--li graf-after--pullquote">To match only one event use <strong class="markup--strong markup--li-strong">emits(matcher)</strong> — This is the most simple one and using this only all other complex Streammatcher are build.</li></ul><h4 name="80ef" id="80ef" class="graf graf--h4 graf-after--li">2.emitsThrough() &amp; emitsDone</h4><figure name="eb6f" id="eb6f" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/imsaravana369/a78f49ecd5cc813d2e699be36832dd26.js"></script></figure><p name="9882" id="9882" class="graf graf--p graf-after--figure">This test looks similar to the first one, right? But not exactly!</p><h4 name="47fb" id="47fb" class="graf graf--h4 graf-after--p">emitsThrough</h4><blockquote name="9e01" id="9e01" class="graf graf--pullquote graf-after--h4"><strong class="markup--strong markup--pullquote-strong">emitsThrough (matcher)</strong> — This consumes all events matched by [matcher], as well as <strong class="markup--strong markup--pullquote-strong">all events before</strong>. If the stream emits a done event without matching the[matcher], this fails and consumes no events.</blockquote><ul class="postList"><li name="24c9" id="24c9" class="graf graf--li graf-after--pullquote"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">Why do we use emitsThough(0) in the above code</em>?</strong> — It<strong class="markup--strong markup--li-strong"> </strong>consumes all the values until 0( equals(0) ) is matched. So it will consume<code class="markup--code markup--li-code"> 3-&gt;2-&gt;1-&gt;0</code></li><li name="4287" id="4287" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">When we use emitThough()?</em></strong> — when we don’t care about the values emitted before the value that is matched with the [matcher]. In the above test, we don&#39;t care about the values 3,2,1.</li></ul><h4 name="60f5" id="60f5" class="graf graf--h4 graf-after--li">emitsDone</h4><blockquote name="021b" id="021b" class="graf graf--pullquote graf-after--h4"><strong class="markup--strong markup--pullquote-strong">emitsDone — </strong>This matcher is used to verify whether the stream has no more items left. (The stream is Done)</blockquote><ul class="postList"><li name="9011" id="9011" class="graf graf--li graf-after--pullquote"><em class="markup--em markup--li-em">why do we use </em><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">emitsDone </em></strong><em class="markup--em markup--li-em">in the above code</em>? — we used it to make sure <strong class="markup--strong markup--li-strong">no other values are emitted after the last value ‘0’</strong> is emitted.</li><li name="2318" id="2318" class="graf graf--li graf-after--li"><em class="markup--em markup--li-em">When we use emitsDone</em>? — To make sure the stream has no other values left to emit.</li></ul><h4 name="4fda" id="4fda" class="graf graf--h4 graf-after--li">3.ExpectAsync()</h4><figure name="5493" id="5493" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/imsaravana369/113f8f7279016a9d9c6328c271e63359.js"></script></figure><blockquote name="159f" id="159f" class="graf graf--pullquote graf-after--figure"><strong class="markup--strong markup--pullquote-strong">ExpectAsync1(callback) — </strong>This function is used to wrap a callback(with one parameter) and make sure the test framework to keep waiting until the callback is called [count] times. If it is not called [count] times or any matcher fails(within the callback), the test will fail.</blockquote><blockquote name="59fa" id="59fa" class="graf graf--blockquote graf-after--pullquote">There are many variation of expectAsync() based on the parameters to the callback like expectAsync2(),expectAsync3(),…expectAsync6()</blockquote><ul class="postList"><li name="22ed" id="22ed" class="graf graf--li graf-after--blockquote"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">why do we use ExpectAsync1(callback) in the above code?</em></strong><em class="markup--em markup--li-em"> — </em>we want our callback to <strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">run exactly four times</em> </strong><em class="markup--em markup--li-em">(which we specified in the </em><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">count </em></strong><em class="markup--em markup--li-em">keyword argument) </em>and also we want to check whether all the values emitted are between the range 0 and 3 inclusively(including both the end values 0 &amp; 3).</li><li name="f978" id="f978" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">When we use ExpectAsyncN(callback)? — </em></strong><em class="markup--em markup--li-em">When we want to validate all the values passed to the callback comply with the same matcher and to make sure the callback is called exactly called [count] times.</em></li></ul><h4 name="0478" id="0478" class="graf graf--h4 graf-after--li">4. neverEmits</h4><figure name="322a" id="322a" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/imsaravana369/f08a56abf6ecebfb23e189dd763b0cfb.js"></script></figure><blockquote name="8188" id="8188" class="graf graf--pullquote graf-after--figure"><strong class="markup--strong markup--pullquote-strong">neverEmits(innerMatcher) </strong>— This matcher is used to check if the stream has not emitted any value that matches the inner matcher.</blockquote><ul class="postList"><li name="6291" id="6291" class="graf graf--li graf-after--pullquote"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">why do we use neverEmits(isNegative) in the above code?</em></strong><em class="markup--em markup--li-em"> — We used to check whether our stream hasn’t emitted any negative values.</em></li><li name="f3fe" id="f3fe" class="graf graf--li graf-after--li graf--trailing"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">When we use neverEmits(innerMatcher)? — </em></strong><em class="markup--em markup--li-em">When we want to ensure not any abnormal values(according to our business logic) are emitted from our stream.</em></li></ul></div></div></section><section name="48d7" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="fbbb" id="fbbb" class="graf graf--h3 graf--leading">Testing Non-deterministic Behaviours</h3><p name="3031" id="3031" class="graf graf--p graf-after--h3">All the above behaviours are deterministic,</p><blockquote name="9e48" id="9e48" class="graf graf--blockquote graf-after--p">Deterministic — for a given input, the outputs are always same. In our case, when we pass 3 to our reverse stream, it will always yield 3-&gt;2-&gt;1-&gt;0.</blockquote><p name="6d2d" id="6d2d" class="graf graf--p graf-after--blockquote">How can we test non-deterministic behaviours, flutter got us covered. We can use <code class="markup--code markup--p-code u-paddingRight0 u-marginRight0"><a href="https://pub.dev/documentation/test_api/latest/test_api/mayEmit.html" data-href="https://pub.dev/documentation/test_api/latest/test_api/mayEmit.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">mayEmit(</a>) or <a href="https://pub.dev/documentation/test_api/latest/test_api/mayEmitMultiple.html" data-href="https://pub.dev/documentation/test_api/latest/test_api/mayEmitMultiple.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">mayEmitMultiple(</a>), </code>for those behaviours. Let’s understand them with an example.</p><p name="8cde" id="8cde" class="graf graf--p graf-after--p">Let’s create another implementation of the MyCounter interface called <strong class="markup--strong markup--p-strong">SurpriseForwardCounter</strong>, which works like ForwardCounter but sometimes may print a random number at the end(a non-deterministic behaviour).</p><figure name="06b9" id="06b9" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/imsaravana369/cc0ff78e0f102a699555cf7cd34c7243.js"></script></figure><p name="9d1f" id="9d1f" class="graf graf--p graf-after--figure">This class is the same as ForwardCounter but we have introduced some randomness at the end.</p><p name="e9ec" id="e9ec" class="graf graf--p graf-after--p">But wait. How can we test that? Let’s see</p><h4 name="69dc" id="69dc" class="graf graf--h4 graf-after--p">1.mayEmits()</h4><figure name="8e59" id="8e59" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/imsaravana369/d06a38c385bda1e580a273d108a12174.js"></script></figure><blockquote name="98e8" id="98e8" class="graf graf--pullquote graf-after--figure">mayEmits(matcher) — This matcher will always succeed, it will consume the value from the stream if it matches the [matcher] otherwise not.</blockquote><ul class="postList"><li name="efa0" id="efa0" class="graf graf--li graf-after--pullquote"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">why do we use </em>mayEmits(matcher)<em class="markup--em markup--li-em"> in the above code? — </em></strong><em class="markup--em markup--li-em">Since the stream may not always emit a random value at the end, we have used mayEmit() to consume the random value only if it&#39;s emitted without failing the test case.</em></li><li name="d653" id="d653" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">When we use </em>mayEmits(matcher)<em class="markup--em markup--li-em">? — </em></strong><em class="markup--em markup--li-em">When we want to consume a value only when it is matched with the [matcher], if not proceed without failing the test case. It is used to deal with non-deterministic behaviours.</em></li></ul><blockquote name="82a7" id="82a7" class="graf graf--pullquote graf-after--li">mayEmitMultiple(matcher) — works like <code class="markup--code markup--pullquote-code">mayEmit()</code>, but it matches events against the matcher as many times as possible.</blockquote><blockquote name="a191" id="a191" class="graf graf--blockquote graf-after--pullquote graf--trailing"><strong class="markup--strong markup--blockquote-strong">Scenerio </strong>— When you replace the<strong class="markup--strong markup--blockquote-strong"> </strong><code class="markup--code markup--blockquote-code u-paddingRight0 u-marginRight0"><strong class="markup--strong markup--blockquote-strong">if</strong>(random.nextBool())</code> statement of SurpriseForwardCounter with <code class="markup--code markup--blockquote-code u-paddingRight0 u-marginRight0"><strong class="markup--strong markup--blockquote-strong">while</strong><em class="markup--em markup--blockquote-em">(random.nextBool())</em>.</code> Then the counter can emit values like <em class="markup--em markup--blockquote-em">0-&gt;1-&gt;2-&gt;3-&gt;random value1 -&gt; random value2 -&gt; … -&gt; random valueN, until the random boolean becomes false. In those scenario we must use mayEmitMultiple() to consume all the random values.</em></blockquote></div></div></section><section name="ab87" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="9ca3" id="9ca3" class="graf graf--p graf--leading">I’ve covered most of the topics regarding unit-testing streams. To explore more you can check out this <a href="https://pub.dev/packages/test" data-href="https://pub.dev/packages/test" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">official document</a> of the test package.</p><p name="5edd" id="5edd" class="graf graf--p graf-after--p graf--trailing">Thanks💖 for reading this article, if you find anything wrong, you’re very welcome to mention that in the comment📃. If you liked this article, clap👏</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@imsaravananm" class="p-author h-card">Saravanan M</a> on <a href="https://medium.com/p/6ed72c19f761"><time class="dt-published" datetime="2021-07-09T10:09:48.938Z">July 9, 2021</time></a>.</p><p><a href="https://medium.com/@imsaravananm/unit-testing-streams-in-dart-flutter-6ed72c19f761" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 7, 2023.</p></footer></article></body></html>