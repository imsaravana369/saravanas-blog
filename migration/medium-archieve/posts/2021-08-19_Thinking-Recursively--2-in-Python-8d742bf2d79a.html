<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Thinking Recursively #2 in Python</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Thinking Recursively #2 in Python</h1>
</header>
<section data-field="subtitle" class="p-summary">
Let‚Äôs solve some complex recursive problems.
</section>
<section data-field="body" class="e-content">
<section name="2db5" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="d25a" id="d25a" class="graf graf--h3 graf--leading graf--title">Thinking Recursively #2 in¬†Python</h3><p name="620e" id="620e" class="graf graf--p graf-after--h3">This is my second article on how to think recursively in python. In my <a href="https://medium.com/nerd-for-tech/thinking-recursively-1-with-python-ac48ae78201a" data-href="https://medium.com/nerd-for-tech/thinking-recursively-1-with-python-ac48ae78201a" class="markup--anchor markup--p-anchor" target="_blank">previous article</a>, I‚Äôve solved some basic recursive problems. In this article, we are going to solve 2 complex recursive problems which will improve the way you think recursively. Let‚Äôs get straight into that.</p><figure name="b049" id="b049" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*toZYWzxITKOCNwBVI8KzsA.jpeg" data-width="4592" data-height="2584" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*toZYWzxITKOCNwBVI8KzsA.jpeg"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@groovelanddesigns?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" data-href="https://unsplash.com/@groovelanddesigns?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Grooveland Designs</a> on¬†<a href="https://unsplash.com/s/photos/spiral?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" data-href="https://unsplash.com/s/photos/spiral?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure><h4 name="74a7" id="74a7" class="graf graf--h4 graf-after--figure">Zig Zag¬†Array</h4><p name="980b" id="980b" class="graf graf--p graf-after--h4">Given an array, tell whether the elements are in a zig-zag manner. Zig-Zag means the elements at an odd position should be smaller(or greater) than their adjacent elements.</p><figure name="1520" id="1520" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*kD5w_AXFpYFIAoAFwizQ0g.png" data-width="1018" data-height="485" src="https://cdn-images-1.medium.com/max/800/1*kD5w_AXFpYFIAoAFwizQ0g.png"></figure><p name="6544" id="6544" class="graf graf--p graf-after--figure">If you look at the problem closely, our logic looks something like this</p><pre name="0783" id="0783" class="graf graf--pre graf-after--p">arr[0]<strong class="markup--strong markup--pre-strong">&lt;</strong>arr[1]<strong class="markup--strong markup--pre-strong">&gt;</strong>arr[2]<strong class="markup--strong markup--pre-strong">&lt;</strong>arr[3]<strong class="markup--strong markup--pre-strong">&gt;</strong>arr[4]‚Ä¶.. (for low-high zig-zag array)<br>DOWN -- UP -- DOWN -- UP -- DOWN -- ...</pre><figure name="2ad6" id="2ad6" class="graf graf--figure graf--iframe graf-after--pre"><script src="https://gist.github.com/imsaravana369/b57dbc471b44c92d96fcdf3ddca668e7.js"></script></figure><pre name="e248" id="e248" class="graf graf--pre graf-after--figure">def isZigZag(arr): <br>    return isUpDown(arr) or isDownUp(arr)</pre><p name="192b" id="192b" class="graf graf--p graf-after--pre">The reason why I‚Äôve taken the <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">logical or </strong></code>is the array is a zigzag array if it is either a <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">high-low</em></strong> zigzag array or a <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">low-high</em></strong> zigzag array.</p><p name="b291" id="b291" class="graf graf--p graf-after--p">Input: [1,5,2,4,1,6]</p><pre name="00e4" id="00e4" class="graf graf--pre graf-after--p">isZigZag([1,5,2,4,1,6])<br>= isUpDown([1,5,2,4,1,6]) or isDownUp([1,5,2,4,1,6])<br>= <strong class="markup--strong markup--pre-strong">False</strong> or isDownUp([1,5,2,4,1,6])<br>= isDownUp([1,5,2,4,1,6])</pre><pre name="34f8" id="34f8" class="graf graf--pre graf-after--pre">=<strong class="markup--strong markup--pre-strong">((1&lt;5) and isUpDown([5,2,4,1,6]))</strong> <br>=(True and <strong class="markup--strong markup--pre-strong">(5&gt;2 and isDownUp([2,4,1,6]))</strong><br>=(True and (True and <strong class="markup--strong markup--pre-strong">( 2&lt;4  and isUpDown([4,1,6])) </strong>)<strong class="markup--strong markup--pre-strong"><br></strong>=(True and (True and (True and <strong class="markup--strong markup--pre-strong">(4&gt;1 and isDownUp([1,6]))</strong>))<br>=(True and (True and (True and (True and <strong class="markup--strong markup--pre-strong">(1&lt;6 and isUpDown([6]))))<br></strong>=(True and (True and (True and (True and (True and <strong class="markup--strong markup--pre-strong">True</strong>))))#basecase<br>= <strong class="markup--strong markup--pre-strong">True</strong></pre><p name="dd00" id="dd00" class="graf graf--p graf-after--pre">We can combine the above two functions and write them recursively as,</p><figure name="8018" id="8018" class="graf graf--figure graf--iframe graf-after--p graf--trailing"><script src="https://gist.github.com/imsaravana369/f889c029a21f60316a20d7353d2fa452.js"></script></figure></div></div></section><section name="ada6" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h4 name="0250" id="0250" class="graf graf--h4 graf--leading">Permutation of a¬†List</h4><p name="4327" id="4327" class="graf graf--p graf-after--h4">I will tell you, how we can arrive at a pure recursive way of finding the permutation of a list( without backtracking). The method is not optimistic but it really makes you understand <em class="markup--em markup--p-em">recursion</em>.</p><p name="7de4" id="7de4" class="graf graf--p graf-after--p">Given a list {arr‚ÇÄ, arr‚ÇÅ,‚Ä¶. arr‚Çô}. We can find the permutation of the list</p><ol class="postList"><li name="f904" id="f904" class="graf graf--li graf-after--p">If we have the permutation of the list starting from {arr‚ÇÅ,‚Ä¶. arr‚Çô}</li><li name="533b" id="533b" class="graf graf--li graf-after--li">Then we insert <code class="markup--code markup--li-code">arr‚ÇÄ</code> in all the positions of each of the permutation sub-arrays that we got from step 1. See the below example for better understanding,</li></ol><p name="dd7d" id="dd7d" class="graf graf--p graf-after--li">Consider the list [1,2,3]</p><pre name="b8ec" id="b8ec" class="graf graf--pre graf-after--p">Step 1: Find the permutation of [2,3]. It is<strong class="markup--strong markup--pre-strong"> [ [2,3], [3,2] ]<br></strong>Step 2: Insert 1 at all the positions of each of the permutation sub-arrays.  </pre><pre name="4f5d" id="4f5d" class="graf graf--pre graf-after--pre">Permutation[0] = [2,3]   //<strong class="markup--strong markup--pre-strong">first sub-array</strong> of permutation([2,3])<br>Insert 1 at index 0 =  [1,2,3]<br>Insert 1 at index 1 =  [2,1,3]<br>Insert 1 at index 2 =  [2,3,1]</pre><pre name="3009" id="3009" class="graf graf--pre graf-after--pre">#############################################</pre><pre name="7f52" id="7f52" class="graf graf--pre graf-after--pre">Permutation[1] = [3,2]   //<strong class="markup--strong markup--pre-strong">second sub-array </strong><br>Insert 1 at index 0 =  [1,3,2]<br>Insert 1 at index 1 =  [3,1,2]<br>Insert 1 at index 2 =  [3,2,1]</pre><p name="c442" id="c442" class="graf graf--p graf-after--pre">This is how we can deduce the permutation of a list recursively.</p><p name="fc43" id="fc43" class="graf graf--p graf-after--p">First, let‚Äôs write a function interleave() that does only <strong class="markup--strong markup--p-strong">step 2.</strong></p><figure name="b4f3" id="b4f3" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/imsaravana369/a241ab3d9f9da97dba3bf3bab49b4e20.js"></script></figure><p name="ef01" id="ef01" class="graf graf--p graf-after--figure">Consider the input¬†: <code class="markup--code markup--p-code u-paddingRight0 u-marginRight0">arr = <strong class="markup--strong markup--p-strong">[2,3,4]</strong>, elementTobeInserted = 1</code></p><p name="9bb1" id="9bb1" class="graf graf--p graf-after--p">Here‚Äôs how the call stack looks like, (you will surely understand the below explanationüòä)</p><blockquote name="397d" id="397d" class="graf graf--blockquote graf-after--p">Below Indentations represent <strong class="markup--strong markup--blockquote-strong">new call stacks</strong></blockquote><pre name="30b0" id="30b0" class="graf graf--pre graf-after--blockquote"><br>&gt;&gt;interleave(1,[2,3,4])<br>1.  res = [1,2,3,4]  #line 12, the possibility that we know for sure<br>    head = 2<br>    tail = [3,4]<br>    #line 14 =&gt; <strong class="markup--strong markup--pre-strong">interleave(elementToBeInserted,tail)</strong> <br>                <strong class="markup--strong markup--pre-strong">interleave(1, [3,4] )</strong> will be called<br>                res = [1,3,4]<br>                head = 3<br>                tail = [4]<br>                #line 14 =&gt; <strong class="markup--strong markup--pre-strong">interleave(1,[4])</strong><br>                            res = [1,4] <br>                            head = 4<br>                            tail =[]<br>                            #line 14 =&gt; interleave(1,[])<br>                                        <strong class="markup--strong markup--pre-strong">returns [[1]] #base-case</strong></pre><pre name="a325" id="a325" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">                            </strong>otherPossiblitiesArr = [[1]]<br>                            add 4(head) to the front =&gt; [[<strong class="markup--strong markup--pre-strong">4</strong>,1]]<strong class="markup--strong markup--pre-strong"><br>                            returns </strong>[<strong class="markup--strong markup--pre-strong">[1,4],</strong>[4,1]]<strong class="markup--strong markup--pre-strong"> </strong></pre><pre name="5194" id="5194" class="graf graf--pre graf-after--pre">                otherPossiblitiesArr= [[1,4],[4,1]]<br>                Add 3(head) to the front =&gt; [[<strong class="markup--strong markup--pre-strong">3</strong>,1,4],[<strong class="markup--strong markup--pre-strong">3</strong>,4,1]]<br>                returns [<strong class="markup--strong markup--pre-strong">[1,3,4]</strong>,[3,1,4],[3,4,1]]<br>              </pre><pre name="32e8" id="32e8" class="graf graf--pre graf-after--pre">   otherPossiblitiesArr = [<strong class="markup--strong markup--pre-strong">[1,3,4]</strong>,[3,1,4],[3,4,1]]<br>   add 2(head) to the front =&gt; [[<strong class="markup--strong markup--pre-strong">2</strong>,1,3,4],[<strong class="markup--strong markup--pre-strong">2</strong>,3,1,4],[<strong class="markup--strong markup--pre-strong">2</strong>,3,4,1]]<br>   returns [<strong class="markup--strong markup--pre-strong">[1,2,3,4]</strong>,[2,1,3,4],[2,3,1,4],[2,3,4,1]]</pre><p name="2a33" id="2a33" class="graf graf--p graf-after--pre">I hope seeing the call stack will clearly tell you how the function works. Let‚Äôs code the permutation function which will use the above <code class="markup--code markup--p-code">interleave()</code> function to deduce all the permutations of the given list.</p><figure name="22df" id="22df" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/imsaravana369/e66d4b71742c51be56419a5cff84e478.js"></script></figure><pre name="ad71" id="ad71" class="graf graf--pre graf-after--figure">&gt;&gt;&gt;permutation([1,2,3,4])<br>#call stack<br>&gt;&gt; head = 1<br>   tail = [2,3,4]<br>   tailPerm = permutation([2,3,4])<br>            &gt;&gt;head = [2]<br>              tail = [3,4]<br>              tailPerm = permutation([3,4])<br>                       &gt;&gt;head = 3<br>                         tail = [4]<br>                         tailPerm = permutation([4])<br>                                    returns <strong class="markup--strong markup--pre-strong">[[4]]</strong> #base-case<br>                         <br>                         <em class="markup--em markup--pre-em">loop 1:</em> interleave(3,[4]) = [[3,4],[4,3]]<br>                         returns <strong class="markup--strong markup--pre-strong">[[3,4],[4,3]]</strong><br>              <br>              <em class="markup--em markup--pre-em">loop 1: </em>interleave(2,[3,4])= [[2,3,4],[3,2,4],[3,4,2]]<br>              <em class="markup--em markup--pre-em">loop 2: </em>interleave(2,[4,3])= [[2,4,3],[4,2,3],[4,3,2]]<br>              returns <strong class="markup--strong markup--pre-strong">[[2,3,4],[3,2,4],[3,4,2],<br>                       [2,4,3],[4,2,3],[4,3,2]]</strong><br>   <br>   <em class="markup--em markup--pre-em">loop 1:</em>interleave(1,[2,3,4]) = [[1,2,3,4],[2,1,3,4],[2,3,1,4],[2,3,4,1]]<br>   .....<br>   <em class="markup--em markup--pre-em">loop 6:</em> interleave(1,[4,3,2]) = [[1,4,3,2],[4,1,3,2],[4,3,1,2],[4,3,2,1]]</pre><pre name="8c52" id="8c52" class="graf graf--pre graf-after--pre">   returns <strong class="markup--strong markup--pre-strong">[[1,2,3,4],[2,1,3,4],[2,3,1,4],[2,3,4,1],.....,[4,3,2,1]]</strong></pre><p name="2f8f" id="2f8f" class="graf graf--p graf-after--pre graf--trailing">As you can see how elegantü¶Ñ the solution is, it&#39;s all about understanding the subproblems. Once you see every problem not as a whole but as a bunch of subproblems, it will be very easy to think recursively.</p></div></div></section><section name="94a8" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="cc20" id="cc20" class="graf graf--p graf--leading">I hope you‚Äôve enjoyed this article and understood the working of recursive functions. If you really like these kinds of recursive functions, I strongly recommend you to learn a functional programming language(<a href="https://www.youtube.com/watch?v=EfmyKgYjNP8&amp;list=PL3pGy4HtqwD2-bYXI3_4LWQyafXp4-olc" data-href="https://www.youtube.com/watch?v=EfmyKgYjNP8&amp;list=PL3pGy4HtqwD2-bYXI3_4LWQyafXp4-olc" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Haskell </a>may be a good place to start from).</p><p name="111d" id="111d" class="graf graf--p graf-after--p graf--trailing">Thanksüôè for reading. Clapüëè if you‚Äôve liked this article. I will write more about recursive functions in my upcoming articles.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@imsaravananm" class="p-author h-card">Saravanan M</a> on <a href="https://medium.com/p/8d742bf2d79a"><time class="dt-published" datetime="2021-08-19T01:59:46.520Z">August 19, 2021</time></a>.</p><p><a href="https://medium.com/@imsaravananm/thinking-recursively-2-in-python-8d742bf2d79a" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 7, 2023.</p></footer></article></body></html>