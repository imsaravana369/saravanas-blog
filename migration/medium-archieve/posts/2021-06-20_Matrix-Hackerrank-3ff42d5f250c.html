<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Matrix Hackerrank</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Matrix Hackerrank</h1>
</header>
<section data-field="subtitle" class="p-summary">
In this article, I’m going to explain to you, step by step, how you can solve the Hackerrank problem “Matrix” which is one of the…
</section>
<section data-field="body" class="e-content">
<section name="cec9" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="c651" id="c651" class="graf graf--h3 graf--leading graf--title">Matrix Hackerrank</h3><p name="2aed" id="2aed" class="graf graf--p graf-after--h3">In this article, I’m going to explain to you, step by step, how you can solve the Hackerrank problem “Matrix” which is one of the significantly hardest problems I’ve come across. This problem is quite hard to explain so bear with me, you will finally understand it. I’m very sure the final example will help you understand it better.</p><figure name="e77d" id="e77d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*8hsvtSX0jyvxyzy9eVClLw.png" data-width="1920" data-height="1080" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*8hsvtSX0jyvxyzy9eVClLw.png"><figcaption class="imageCaption">Image source: <a href="http://www.usatoday.com" data-href="http://www.usatoday.com" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">www.usatoday.com</a></figcaption></figure><p name="8ece" id="8ece" class="graf graf--p graf-after--figure">To those who don’t know about <a href="https://www.hackerrank.com/challenges/matrix/problem?h_r=internal-search" data-href="https://www.hackerrank.com/challenges/matrix/problem?h_r=internal-search" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">this problem</a>, let me share with you the problem statement</p><h4 name="c3d4" id="c3d4" class="graf graf--h4 graf-after--p">Problem Statement</h4><p name="34c2" id="34c2" class="graf graf--p graf-after--h4"><em class="markup--em markup--p-em">The kingdom of Zion has cities connected by bidirectional roads. There is a </em><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">unique path between any pair of cities</em></strong><em class="markup--em markup--p-em">. Morpheus has found out that the machines are planning to destroy the whole kingdom. If two machines can join forces, they will attack. Neo has to destroy roads connecting cities with machines to stop them from joining forces. There must not be any path connecting two machines.</em></p><p name="729e" id="729e" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">Each of the roads takes an amount of time to destroy, and only one can be worked on at a time. Given a list of edges and times, determine the minimum time to stop the attack.</em></p><p name="bd8f" id="bd8f" class="graf graf--p graf-after--p">For example, there are n=5 cities called 0–4. Three of them have machines and are colored red. The time to destroy is shown next to each road. If we cut the two green roads, there are no paths between any two machines. The time required is <strong class="markup--strong markup--p-strong">3+5</strong>.</p><p name="6c84" id="6c84" class="graf graf--p graf-after--p">Here is an example,</p><figure name="b0aa" id="b0aa" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*dEJmeiGe8WHkCCs4CFPQlg.png" data-width="280" data-height="167" src="https://cdn-images-1.medium.com/max/800/1*dEJmeiGe8WHkCCs4CFPQlg.png"><figcaption class="imageCaption">Fig 1: The Final output should be 5</figcaption></figure><p name="19a3" id="19a3" class="graf graf--p graf-after--figure">Now let’s see how we can interpret the problem.</p><ol class="postList"><li name="54e6" id="54e6" class="graf graf--li graf-after--p">The path must be a <strong class="markup--strong markup--li-strong">Tree</strong>. But how? From the question, you can find out that there is a unique path between any pair of cities. In trees, You can reach a node only from one node(its parent node).</li><li name="3689" id="3689" class="graf graf--li graf-after--li">We need to split the one big tree with ’n’ machine nodes into ’n’ separate subtrees(Why? So that no machine node is reachable from one another). To do that we have to remove n-1 edges.</li></ol><h3 name="06ef" id="06ef" class="graf graf--h3 graf-after--li">Traverse the tree using DFS</h3><p name="8891" id="8891" class="graf graf--p graf-after--h3">We need to traverse the tree using DFS, we need to do the below operations to each subtree starting from the bottom to top in a DFS style.</p><p name="3217" id="3217" class="graf graf--p graf-after--p">Before explaining the actual algorithm, I would introduce some <strong class="markup--strong markup--p-strong">Terminologies</strong>(self-created) to help me explain this problem better.</p><h3 name="caf6" id="caf6" class="graf graf--h3 graf-after--p">Nearest Machine Nodes from a Node</h3><p name="da47" id="da47" class="graf graf--p graf-after--h3">Consider a node, there can be ‘x’ paths to all of its descendant machine nodes. The <strong class="markup--strong markup--p-strong">nearest machine nodes</strong> are the nodes that are nearer to the current node in their respective paths. I will call them, the <strong class="markup--strong markup--p-strong">nearest machine nodes </strong>to explain this better. (don’t consider the weights of the edges)</p><figure name="82f7" id="82f7" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*rmwmPoQeIzhUC8nc5MX8rg.png" data-width="404" data-height="426" src="https://cdn-images-1.medium.com/max/800/1*rmwmPoQeIzhUC8nc5MX8rg.png"><figcaption class="imageCaption">Fig 2: Here the nearest machine nodes of A are<strong class="markup--strong markup--figure-strong"> B and F</strong>. E is also a machine descendant of A but not a nearer one since it’s preceded by B in the path from A to E.</figcaption></figure><h4 name="06e7" id="06e7" class="graf graf--h4 graf-after--figure">Preparing the questions</h4><p name="9491" id="9491" class="graf graf--p graf-after--h4">We are going to ask two questions while visiting each node(parent of the subtree).</p><ol class="postList"><li name="7535" id="7535" class="graf graf--li graf-after--p">If the current node is a normal node(not a machine-occupied city), let’s say it has ‘K’ <strong class="markup--strong markup--li-strong">nearest machine nodes. </strong>we are going to remove K-1 edges(one edge from each path of the current node to all of the nearest machine nodes, but why K-1? I will tell it later)</li><li name="c26a" id="c26a" class="graf graf--li graf-after--li">If it is a machine node, we should remove all the K edges. It will completely disconnect the current machine node from all the other nearest machine nodes.</li></ol><h4 name="4c64" id="4c64" class="graf graf--h4 graf-after--li">Condition 1: If the current node is a normal node</h4><p name="1741" id="1741" class="graf graf--p graf-after--h4"><strong class="markup--strong markup--p-strong">What should we do?</strong> Remove K-1 edges from each of the paths to all the nearest machine nodes.</p><p name="4878" id="4878" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">How do we decide which edge to remove from the path? </strong>(from the current node to the nearest machine node) Simply remove the edge with the shortest weight in the path(I will call this <strong class="markup--strong markup--p-strong">“minimal cost”</strong> )? Make sense? By doing this we are removing the connection between the current non-machine node with its descendant machine node at a minimal cost.</p><figure name="51b2" id="51b2" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*SkCkss1yxQuq18_DgnqgvQ.png" data-width="669" data-height="593" src="https://cdn-images-1.medium.com/max/800/1*SkCkss1yxQuq18_DgnqgvQ.png"><figcaption class="imageCaption">Fig 3: Consider <strong class="markup--strong markup--figure-strong">A</strong> as the current node. The paths to the nearest machine nodes from A are <strong class="markup--strong markup--figure-strong">A-&gt;B, A-&gt;C-&gt;F, A-&gt;D</strong>. Here the minimal costs are <strong class="markup--strong markup--figure-strong">10,2,7</strong> respectively.</figcaption></figure><p name="c3b4" id="c3b4" class="graf graf--p graf-after--figure">Now having decided which edge to remove from the k-1 paths. Now, the next question is <strong class="markup--strong markup--p-strong">“Which k-1 paths to consider?”</strong></p><p name="ad6d" id="ad6d" class="graf graf--p graf-after--p">The Answer is to consider all the paths except the one with the highest “<em class="markup--em markup--p-em">minimal cost</em>”. In the above example, we will remove the edges with costs 2,7 neglecting the path A -&gt;B, which has the highest minimal cost.</p><p name="170a" id="170a" class="graf graf--p graf-after--p">We can <strong class="markup--strong markup--p-strong">Bubble up</strong> the highest minimal cost. Why? This is an optimization step, you can gracefully skip this and still solve the problem. But to the optimistic folks, I will explain how to do the “Bubbling Up” in the below section.</p><h4 name="02d2" id="02d2" class="graf graf--h4 graf-after--p">Condition 2: If the current node is a Machine node</h4><p name="4410" id="4410" class="graf graf--p graf-after--h4">This step is the same as that of condition 1 but you need to do the pruning for all the k paths instead of k-1 paths.</p><h3 name="37a6" id="37a6" class="graf graf--h3 graf-after--p">Bubbling up the highest minimal cost of Condition 1</h3><p name="e461" id="e461" class="graf graf--p graf-after--h3">Why do we need this step? As I already told it’s just an optimization step.</p><p name="a578" id="a578" class="graf graf--p graf-after--p">Let’s Consider the above tree(figure:3), what if the node I marked with “<strong class="markup--strong markup--p-strong">?</strong>” is a machine node. After visiting A, ‘B’ is still reachable from A. So ‘B’ is also reachable from ‘?’. Which is Bad!!</p><p name="3589" id="3589" class="graf graf--p graf-after--p">According to DFS, the next node we backtrack from A is M(the ‘?’ node), let’s say we don’t use “Bubbling up” we need to calculate the minimal cost from M-&gt;B, which is the only nearest machine node of M.</p><p name="13dc" id="13dc" class="graf graf--p graf-after--p">But Wait we already knew what’s the minimal cost of A-&gt;B, we can reuse that. If we bubble up the minimal cost of A-&gt;B (that is 10). Now the minimal cost of M-&gt;B is the minimum of M-&gt;A and A-&gt;B (which we got from the bubbling up step).</p><figure name="cb75" id="cb75" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*gIqQvfPim6d0RP3qxh6wHA.png" data-width="1454" data-height="816" src="https://cdn-images-1.medium.com/max/800/1*gIqQvfPim6d0RP3qxh6wHA.png"><figcaption class="imageCaption">As you can see, we will bubble up B’s value as it is the highest minimal cost of A. Now we will compare M-&gt;A paths minimal cost, that is 14, and A-&gt;B minimal cost that is 10. Since 10 is the minimum we will chop that edge. Finally, we have chopped the edges with weights 10,2,7. Now all our machine nodes are disconnected from each other.</figcaption></figure><p name="177e" id="177e" class="graf graf--p graf-after--figure">Let’s use this algorithm to solve one of the example problems</p><h4 name="88f7" id="88f7" class="graf graf--h4 graf-after--p">Step 1:</h4><p name="cedd" id="cedd" class="graf graf--p graf-after--h4">Consider the figure <em class="markup--em markup--p-em">fig:1</em>, let’s start the DFS from one of the Machine Nodes. Let’s take node <strong class="markup--strong markup--p-strong">4</strong></p><figure name="52cf" id="52cf" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*314SMYk1HG0tcaVenPbwMg.png" data-width="248" data-height="471" src="https://cdn-images-1.medium.com/max/800/1*314SMYk1HG0tcaVenPbwMg.png"><figcaption class="imageCaption">Initial Tree</figcaption></figure><h4 name="f768" id="f768" class="graf graf--h4 graf-after--figure">Step 2:</h4><p name="63e5" id="63e5" class="graf graf--p graf-after--h4">By DFS, we will end up in the last subtree with the parent as 1, there are 2 nearest machine nodes 2,3 with minimal costs 3 and 7 respectively. Let’s remove the minimal edge that is 1-&gt;3. Time taken will be 3</p><figure name="46f2" id="46f2" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*mqu4bg_IG_kAiFdchDKfxw.png" data-width="278" data-height="428" src="https://cdn-images-1.medium.com/max/800/1*mqu4bg_IG_kAiFdchDKfxw.png"></figure><h4 name="2f7e" id="2f7e" class="graf graf--h4 graf-after--figure">Step 3</h4><p name="6b8c" id="6b8c" class="graf graf--p graf-after--h4">Let’s move one level above(DFS backtracking), now our current node is 0 since it’s a non-machine node we need to remove k-1 edges, now if you consider from node 0, there is only one nearest machine node ( k=1), that is node 3, so we need not remove any edges.</p><figure name="2c42" id="2c42" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*zxpbOygGVjPHRuPgLYd7aA.png" data-width="275" data-height="455" src="https://cdn-images-1.medium.com/max/800/1*zxpbOygGVjPHRuPgLYd7aA.png"></figure><h4 name="3921" id="3921" class="graf graf--h4 graf-after--figure">Step 4</h4><p name="c6d6" id="c6d6" class="graf graf--p graf-after--h4">Now our current node is 4, Since node 4 is a machine node, we need to remove all the nearest machine nodes, here k=1 since the only nearest machine node is node 3 and the minimal path cost from 4-&gt;3 is 2. So let’s remove the edge 4-&gt;0. Time taken will become 5.</p><figure name="16d9" id="16d9" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*2DtBNKWLObJ11Ge4xduWow.png" data-width="268" data-height="439" src="https://cdn-images-1.medium.com/max/800/1*2DtBNKWLObJ11Ge4xduWow.png"></figure><h4 name="f377" id="f377" class="graf graf--h4 graf-after--figure">Finally, we freed Zion</h4><p name="c58f" id="c58f" class="graf graf--p graf-after--h4">We have demolished the roads 4-&gt;0 and 1-&gt;2 within the <strong class="markup--strong markup--p-strong">time 5</strong> and saved Zion from the machines(yes!). The Zion Kingdom finally looks like</p><figure name="5336" id="5336" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*GgJzXp-n4sl2ALiFxXXz2A.png" data-width="268" data-height="427" src="https://cdn-images-1.medium.com/max/800/1*GgJzXp-n4sl2ALiFxXXz2A.png"><figcaption class="imageCaption">Final Tree where all the machine nodes are disconnected from one another</figcaption></figure><p name="5d64" id="5d64" class="graf graf--p graf-after--figure graf--trailing">Thank you for going through this article. Hope I’ve helped you understand the logic behind this solution. I will soon upload the python code and dissect each line of the code to help you understand the logic better.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@imsaravananm" class="p-author h-card">Saravanan M</a> on <a href="https://medium.com/p/3ff42d5f250c"><time class="dt-published" datetime="2021-06-20T17:45:22.697Z">June 20, 2021</time></a>.</p><p><a href="https://medium.com/@imsaravananm/matrix-hackerrank-3ff42d5f250c" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 7, 2023.</p></footer></article></body></html>