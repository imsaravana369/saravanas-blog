<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Thinking Recursively #1 with Python</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Thinking Recursively #1 with Python</h1>
</header>
<section data-field="subtitle" class="p-summary">
In this article, I have solved 6 problems recursively to help you understand recursion better.
</section>
<section data-field="body" class="e-content">
<section name="a19f" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="c78b" id="c78b" class="graf graf--h3 graf--leading graf--title">Thinking Recursively #1</h3><p name="2743" id="2743" class="graf graf--p graf-after--h3">Recursion is one of the hard concepts to grasp in programming. Even though we all started our programming journey by writing a recursive factorial function, well after that, most of us take the iterative approach(loops) for solving problems. Even I’ve done the same. But I found how fascinating recursive functions are after taking a Haskell Course. So I thought of sharing it with you.</p><p name="e147" id="e147" class="graf graf--p graf-after--p">I’ve decided to replicate the Haskell recursive functions in python. I will also provide pseudo-codes so that anyone can understand the logic.</p><p name="19d9" id="19d9" class="graf graf--p graf-after--p">This article will introduce you to some basic recursive functions, which are very relevant for grasping recursion concepts, I will write about more advanced ones in future articles.</p><figure name="a5f5" id="a5f5" class="graf graf--figure graf-after--p graf--trailing"><img class="graf-image" data-image-id="1*5DCww_beoZoJCNE3cCk7ug.jpeg" data-width="3264" data-height="2448" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*5DCww_beoZoJCNE3cCk7ug.jpeg"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@luddelorentz?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" data-href="https://unsplash.com/@luddelorentz?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Ludde Lorentz</a> on <a href="https://unsplash.com/s/photos/infinite-spiral?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" data-href="https://unsplash.com/s/photos/infinite-spiral?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure></div></div></section><section name="71c3" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h4 name="b6c6" id="b6c6" class="graf graf--h4 graf--leading">Base Case</h4><p name="912e" id="912e" class="graf graf--p graf-after--h4">Recursion is nothing but a function calling itself. But how does a function know it’s time to stop calling itself. That is called <strong class="markup--strong markup--p-strong">base cases</strong>. Every recursive function has <strong class="markup--strong markup--p-strong">at least one base case</strong>.</p><h4 name="9ca1" id="9ca1" class="graf graf--h4 graf-after--p">How do we know what are the base cases?</h4><p name="d23f" id="d23f" class="graf graf--p graf-after--h4">They are the smallest units of the recursive function whose output we know in advance. For example</p><blockquote name="68bd" id="68bd" class="graf graf--blockquote graf-after--p">•We know the factorial of 0 is 1, so it is the base case of the factorial function.</blockquote><blockquote name="98af" id="98af" class="graf graf--blockquote graf-after--blockquote">•We know the 1st Fibonacci number is 1 &amp; 2nd Fibonacci number is also 1. So they are the base conditions for finding the nth Fibonacci number recursive function.</blockquote><p name="6384" id="6384" class="graf graf--p graf-after--blockquote">In this article, we will see how we can solve the below-given problems recursively</p><blockquote name="12bb" id="12bb" class="graf graf--pullquote graf-after--p">1. Factorial</blockquote><blockquote name="c6cc" id="c6cc" class="graf graf--pullquote graf-after--pullquote">2. GCD of a number</blockquote><blockquote name="447d" id="447d" class="graf graf--pullquote graf-after--pullquote">3. Reverse a Number</blockquote><blockquote name="ba2a" id="ba2a" class="graf graf--pullquote graf-after--pullquote">4. Integer Log of base K</blockquote><blockquote name="40a1" id="40a1" class="graf graf--pullquote graf-after--pullquote">5. Largest Divisor of a number</blockquote><blockquote name="ae04" id="ae04" class="graf graf--pullquote graf-after--pullquote">6. Length of a list</blockquote><h4 name="651c" id="651c" class="graf graf--h4 graf-after--pullquote">1.Factorial</h4><p name="a0bb" id="a0bb" class="graf graf--p graf-after--h4">Consider the below recursive factorial function,</p><figure name="36bc" id="36bc" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/imsaravana369/b805807117e60cd8c0bbdd0278c138c6.js"></script></figure><pre name="dea1" id="dea1" class="graf graf--pre graf-after--figure">&gt;&gt; factorial(5)<br><strong class="markup--strong markup--pre-strong">120</strong></pre><p name="fed2" id="fed2" class="graf graf--p graf-after--pre">If you look at how the function call takes place, it will look something like</p><pre name="d076" id="d076" class="graf graf--pre graf-after--p">factorial(5)<br>5*factorial(4)<br>5*(<strong class="markup--strong markup--pre-strong">4*factorial(3)</strong>)<br>5*(4*<strong class="markup--strong markup--pre-strong">(3*factorial(2))</strong>)<br>5*(4*(3*<strong class="markup--strong markup--pre-strong">(2*factorial(1))</strong>))<br>5*(4*(3*(2*<strong class="markup--strong markup--pre-strong">(1*factorial(0))</strong>))) //base-case<br>5*(4*(3*(2*(1*<strong class="markup--strong markup--pre-strong">1</strong>))))   //factorial(0) returns 1<br>5*(4*(3*(2*1)))<br>5*(4*(3*2))<br>5*(4*6)<br>5* 24<br>120</pre><p name="d414" id="d414" class="graf graf--p graf-after--pre">If I don’t specify the base case, the function keeps on calling itself which will result in Stack Overflow.</p><pre name="c1af" id="c1af" class="graf graf--pre graf-after--p graf--trailing">#if base case isn&#39;t specified<br>5*(4*(3*(2*(1*<strong class="markup--strong markup--pre-strong">(0*factorial(-1))</strong>))))<br>5*(4*(3*(2*(1*(0*(-1*<strong class="markup--strong markup--pre-strong">factorial(-2)))</strong>))))<br>...<br>...</pre></div></div></section><section name="c024" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h4 name="c5a6" id="c5a6" class="graf graf--h4 graf--leading"><strong class="markup--strong markup--h4-strong">2.Computing GCD</strong></h4><p name="45cf" id="45cf" class="graf graf--p graf-after--h4">Do you know how we can compute the <a href="https://en.wikipedia.org/wiki/Greatest_common_divisor" data-href="https://en.wikipedia.org/wiki/Greatest_common_divisor" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">gcd </a>of a number recursively? Its quite simple</p><pre name="2379" id="2379" class="graf graf--pre graf-after--p">FUNCTION INTEGER GCD (INTEGER NUM1, INTEGER NUM2)<br>        if NUM1==0 <br>            RETURN NUM2<br>        else<br>            RETURN GCD(NUM2, NUM2 MOD NUM1)</pre><figure name="e8c0" id="e8c0" class="graf graf--figure graf--iframe graf-after--pre"><script src="https://gist.github.com/imsaravana369/0592639130485bb4110653de4aa8d4fe.js"></script><figcaption class="imageCaption">python code for gcd</figcaption></figure><pre name="d013" id="d013" class="graf graf--pre graf-after--figure graf--trailing">gcd(20,25)  <br>gcd(25%20,20) =&gt; gcd(5,20)  <br>gcd(20%5,5)  =&gt;  gcd(0,5)<br><strong class="markup--strong markup--pre-strong">5 is returned  since basecase is met (num1=0)</strong></pre></div></div></section><section name="5e5f" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h4 name="b911" id="b911" class="graf graf--h4 graf--leading">3.Reversing a Number</h4><p name="dbef" id="dbef" class="graf graf--p graf-after--h4">Given a number “1234”, our goal is to reverse it as “4321” How can we do that recursively?</p><pre name="fb06" id="fb06" class="graf graf--pre graf-after--p">//PSEUDOCODE<br>FUNCTION INTEGER <strong class="markup--strong markup--pre-strong">REVERSENUMBER</strong>(INTEGER N)<br>     return REVERSENUMBER_UTIL(N,0)</pre><pre name="c892" id="c892" class="graf graf--pre graf-after--pre">FUNCTION INTEGER <strong class="markup--strong markup--pre-strong">REVERSENUMBER_UTIL</strong>(INTEGER N, INTEGER RES)<br>     IF N==0<br>         RETURN RES <br>     ELSE<br>         INTEGER REM = N MOD 10<br>         INTEGER QUOTIENT = N DIV 10<br>         RETURN REVERSENUMBER_UTIL(QUOTIENT, RES*10 + REM ))</pre><p name="66b4" id="66b4" class="graf graf--p graf-after--pre">If you look at the pseudo-code, I have separated the reverse() function into <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">reverse(n)</strong></code> and <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">reverseUtil(n,res)</strong></code><strong class="markup--strong markup--p-strong"> </strong>This is very common in recursive functions. Inside the <code class="markup--code markup--p-code">reverse()</code> function(the function that is called by the user) we can do configuration changes like setting the default values, do some validation checks, etc, then call the utility function from the function, which is the real recursive function.</p><ul class="postList"><li name="1118" id="1118" class="graf graf--li graf-after--p">I’m passing the default value as <strong class="markup--strong markup--li-strong">0 to the parameter ‘res’. </strong>So that user can call the function with<code class="markup--code markup--li-code"> reverse(n)</code> instead of <code class="markup--code markup--li-code">reverse(n,0)</code> (We are hiding the implementation details here)</li><li name="af78" id="af78" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Validation Checks</strong> — Our function will fail if we pass negative values. So before calling the actual recursive function. We can throw an error if the value passed is a negative number or we can change it into a positive number then pass it to the utility function.</li></ul><pre name="734a" id="734a" class="graf graf--pre graf-after--li">FUNCTION INTEGER <strong class="markup--strong markup--pre-strong">REVERSENUMBER</strong>(INTEGER N)<br>    IF N&gt;=0<br>        return REVERSENUMBER_UTIL(N,0)<br>    ELSE<br>        return <strong class="markup--strong markup--pre-strong">-1 * REVERSENUMBER(-N)</strong></pre><figure name="1699" id="1699" class="graf graf--figure graf--iframe graf-after--pre"><script src="https://gist.github.com/imsaravana369/5ce041e5de35c1121176ddfad8bda2c1.js"></script><figcaption class="imageCaption">Python code</figcaption></figure><p name="9907" id="9907" class="graf graf--p graf-after--figure">In python, we have a concept called default parameter. If you don’t specify a value to that parameter its default value is used. So you can call the above function with</p><pre name="b7df" id="b7df" class="graf graf--pre graf-after--p">&gt;&gt;&gt; reverse(1234)   <br>4321</pre><p name="c8e7" id="c8e7" class="graf graf--p graf-after--pre">Let&#39;s see how the functions are resolved behind the hood,</p><pre name="84e9" id="84e9" class="graf graf--pre graf-after--p">1.<strong class="markup--strong markup--pre-strong">reverse(1234)</strong></pre><pre name="e0a2" id="e0a2" class="graf graf--pre graf-after--pre">2.reverse(1234/10, 0*10+ 1234%10) <br>  reverse(123, 0+4)<br>  <strong class="markup--strong markup--pre-strong">reverse(123, 4)</strong></pre><pre name="83f8" id="83f8" class="graf graf--pre graf-after--pre">3.reverse(123/10, 4*10 + 123%10)<br>  reverse(12, 4*10 + 3)<br>  <strong class="markup--strong markup--pre-strong">reverse(12,43)</strong></pre><pre name="36d0" id="36d0" class="graf graf--pre graf-after--pre">4.reverse(12/10, 43*10 + 12%10)<br>  reverse(1, 430+2)<br>  <strong class="markup--strong markup--pre-strong">reverse(1,432)</strong></pre><pre name="62b3" id="62b3" class="graf graf--pre graf-after--pre">5.reverse(1/10,432*10 + 1%10)<br>  reverse(0, 4320 + 1)<br>  reverse(0,4321)</pre><pre name="f485" id="f485" class="graf graf--pre graf-after--pre graf--trailing">6. Base case hit (n=0)<br>   so, return 4321 </pre></div></div></section><section name="94ca" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h4 name="07fe" id="07fe" class="graf graf--h4 graf--leading">4. Computing Integer Log of base k</h4><blockquote name="e176" id="e176" class="graf graf--pullquote graf-after--h4"><em class="markup--em markup--pullquote-em">Log of a number is the power to which the base should be raised to get the number.</em></blockquote><p name="0758" id="0758" class="graf graf--p graf-after--pullquote">For eg. Logₖ(N) = x . The expression says ‘<strong class="markup--strong markup--p-strong">k’ raised to the power x gives N.</strong></p><pre name="c741" id="c741" class="graf graf--pre graf-after--p">log₂(8) = 3<br>2³ will give 8</pre><p name="e1b8" id="e1b8" class="graf graf--p graf-after--pre">In, Integer Log we will floor the result, for example</p><blockquote name="66f0" id="66f0" class="graf graf--blockquote graf-after--p">log₂(9) = <strong class="markup--strong markup--blockquote-strong">3.169925</strong></blockquote><p name="ea1f" id="ea1f" class="graf graf--p graf-after--blockquote">We fill floor it and return the result as 3</p><pre name="e071" id="e071" class="graf graf--pre graf-after--p">FUNCTION INTEGER_LOG(INTEGER N, INTEGER BASE)</pre><pre name="2d81" id="2d81" class="graf graf--pre graf-after--pre">        IF N&lt;BASE OR BASE&lt;=1:<br>              RETURN 0</pre><pre name="d5f5" id="d5f5" class="graf graf--pre graf-after--pre">        ELSE<br>            RETURN 1 + INTEGER_LOG(N DIV 10, BASE)</pre><p name="f5db" id="f5db" class="graf graf--p graf-after--pre">The base condition is</p><ol class="postList"><li name="3d35" id="3d35" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">N&lt;Base</code> that means if the number is less than the <code class="markup--code markup--li-code">base </code>then return 0 because the <code class="markup--code markup--li-code">base </code>raised to any power(≥1) will always yield value more than n. E.g logₙ(1),logₙ(2),…logₙ(n-1) will always yield 0.</li><li name="f429" id="f429" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">Base≤1</code> This is very apparent, logₖ(n) = undefined for any k≤1.</li></ol><figure name="fdae" id="fdae" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/imsaravana369/5f5c05583b8639c17d2e42fbef5bda92.js"></script></figure><pre name="4e5b" id="4e5b" class="graf graf--pre graf-after--figure">intLog(20,2)<br>= <strong class="markup--strong markup--pre-strong">1+intLog(10,2)</strong><br>= 1+<strong class="markup--strong markup--pre-strong">(1+intLog(5,2))</strong><br>= 1+(1+<strong class="markup--strong markup--pre-strong">(1+(intLog(2,2))</strong>))<br>= 1+(1+(1+<strong class="markup--strong markup--pre-strong">(1+(intLog(1,2))</strong>))<br>= 1+(1+(1+(1+<strong class="markup--strong markup--pre-strong">0</strong>))))  #base-case hit, n&lt;base, 1&lt;2<br>= 4</pre><h4 name="d640" id="d640" class="graf graf--h4 graf-after--pre">5. Largest Divisor</h4><p name="c5d0" id="c5d0" class="graf graf--p graf-after--h4">Given a number, find the largest divisor of that number.</p><blockquote name="28e2" id="28e2" class="graf graf--blockquote graf-after--p">E.g</blockquote><blockquote name="3659" id="3659" class="graf graf--blockquote graf-after--blockquote">Largest Divisor of 50 is 25</blockquote><blockquote name="4efa" id="4efa" class="graf graf--blockquote graf-after--blockquote">Largest Divisor of 25 is 5</blockquote><blockquote name="31bd" id="31bd" class="graf graf--blockquote graf-after--blockquote">Largest Divisor of 17 is 1</blockquote><p name="25ed" id="25ed" class="graf graf--p graf-after--blockquote">The PseudoCode is</p><pre name="d402" id="d402" class="graf graf--pre graf-after--p">FUNCTION INTEGER <strong class="markup--strong markup--pre-strong">LARGESTDIVISOR</strong>(INTEGER N)<br>     IF N&gt;=0 <br>         RETURN LARGESTDIVISOR_UTIL(N, N DIV 2)<br>     ELSE<br>        RETURN LARGESTDIVISOR(-N)<br>-----------------------------------------------------<br>FUNCTION INTEGER <strong class="markup--strong markup--pre-strong">LARGESTDIVISOR_UTIL</strong>(INTEGER num, INTEGER divisor)<br>     IF (divisor==1) OR ((num MOD divisor)==0)<br>         RETURN B  <br>     ELSE<br>         RETURN <strong class="markup--strong markup--pre-strong">LARGESTDIVISOR_UTIL</strong>(num,divisor-1)</pre><ol class="postList"><li name="f5a7" id="f5a7" class="graf graf--li graf-after--pre">If N≥0, we are calling the utility function with N and N/2. The reason why N/2 is, it is the upper bound of the largest divisor, meaning the largest divisor of any number is half the number <code class="markup--code markup--li-code">n</code>.E.g</li></ol><pre name="a1ad" id="a1ad" class="graf graf--pre graf-after--li">Divisor of 30 is  2,3,5,6,10,15.<br>Divisor of 15 is  3,5. </pre><p name="d132" id="d132" class="graf graf--p graf-after--pre">Because for any number k after N/2, <code class="markup--code markup--p-code">k*2&gt;N</code> So it’s just a waste of computation to search after N/2 because it’s always going to fail.</p><p name="27f8" id="27f8" class="graf graf--p graf-after--p">2. If N&lt;0, we convert the negative number to a positive number and pass it to the same function once again. E.g</p><pre name="0e50" id="0e50" class="graf graf--pre graf-after--p">LARGESTDIVISOR(<strong class="markup--strong markup--pre-strong">-5</strong>) WILL CALL<strong class="markup--strong markup--pre-strong"> LARGESTDIVISOR(5)</strong></pre><p name="84eb" id="84eb" class="graf graf--p graf-after--pre">The logic behind the Util function is we are trying all the numbers from <code class="markup--code markup--p-code">N/2 … 1</code> So the first number that divides the Number should be the largest divisor.</p><p name="2d4f" id="2d4f" class="graf graf--p graf-after--p">In the Util function, the base condition is</p><ol class="postList"><li name="e601" id="e601" class="graf graf--li graf-after--p">If the <code class="markup--code markup--li-code">divisor</code> parameter reaches 1, which means it can’t be divided by any other number so it is a prime number. Divisors of any prime number are <strong class="markup--strong markup--li-strong">1 &amp; itself</strong>. So the largest divisor is 1. (we can’t take the number itself as its largest divisor)</li><li name="7d07" id="7d07" class="graf graf--li graf-after--li">When the ‘<strong class="markup--strong markup--li-strong">num’ modulo the ‘divisor’ is 0</strong>, that means the <code class="markup--code markup--li-code">divisor</code> variable is a divisor of the number. Then we can return the <code class="markup--code markup--li-code">divisor</code>.</li></ol><figure name="6892" id="6892" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/imsaravana369/b740a66cb54affa51fc9c3fabadddddc.js"></script><figcaption class="imageCaption">python code</figcaption></figure><pre name="ccb8" id="ccb8" class="graf graf--pre graf-after--figure">largestDivisor(15) <br>= largest_div_util(15,15/2)<br>largest_div_util(15,7)<br>largest_div_util(15,6)<br><strong class="markup--strong markup--pre-strong">largest_div_util(15,5)</strong>  #base-condition met: a%b==0 so return 5<br>5</pre><h4 name="6e1d" id="6e1d" class="graf graf--h4 graf-after--pre">6. Length of a list</h4><p name="5f14" id="5f14" class="graf graf--p graf-after--h4">Have you ever thought of how we can find the length of a list recursively? Let’s see</p><pre name="32b0" id="32b0" class="graf graf--pre graf-after--p">FUNCTION INTEGER LENGTH(LIST L)<br>     IF L.ISEMPTY() <br>           RETURN 0<br>     ELSE<br>          RETURN 1 + LENGTH[1..n]  </pre><p name="1e79" id="1e79" class="graf graf--p graf-after--pre">Base Condition: We know the length of an empty list is 0</p><p name="609b" id="609b" class="graf graf--p graf-after--p">Logic: The length of a nonempty list is, 1 plus the <strong class="markup--strong markup--p-strong">length </strong>of the remaining elements excluding the first element. We call it the <strong class="markup--strong markup--p-strong">tail of the list</strong>.</p><pre name="bf64" id="bf64" class="graf graf--pre graf-after--p">tail of [1,2,3,4] is [2,3,4] </pre><figure name="e00b" id="e00b" class="graf graf--figure graf--iframe graf-after--pre"><script src="https://gist.github.com/imsaravana369/cbe723bcceeb223ee5b5a026841f504a.js"></script></figure><pre name="ebc7" id="ebc7" class="graf graf--pre graf-after--figure graf--trailing">length([1,2,3,4,5])<br>=1+length([2,3,4,5])<br>=1+(<strong class="markup--strong markup--pre-strong">1+ length([3,4,5]))</strong><br>=1+(1+<strong class="markup--strong markup--pre-strong">(1+length([4,5]))</strong>)<br>=1+(1+(1+<strong class="markup--strong markup--pre-strong">(1+length([5]))</strong>))<br>=1+(1+(1+(1+<strong class="markup--strong markup--pre-strong">(1+length([]))</strong>)))<br>=1+(1+(1+(1+(1+<strong class="markup--strong markup--pre-strong">0</strong>))))  #base condition: length([]) = 0<br><strong class="markup--strong markup--pre-strong">output: 5</strong></pre></div></div></section><section name="b51a" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="44c8" id="44c8" class="graf graf--p graf--leading">The iterative approach is more optimized than the recursive approach but yet as a programmer, we all need to experience the magic of recursion and since the world is slowly moving from object-oriented to functional programming, learning to solve a program recursively will surely make you a better functional programmer.</p><p name="49c2" id="49c2" class="graf graf--p graf-after--p graf--trailing">Thank you for reading this article, we have seen some beginner-level recursive functions, in my next article, we will explore some more complex recursive functions which I find very useful and elegant. Clap👏 if you’ve liked this article.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@imsaravananm" class="p-author h-card">Saravanan M</a> on <a href="https://medium.com/p/ac48ae78201a"><time class="dt-published" datetime="2021-08-17T01:37:18.538Z">August 17, 2021</time></a>.</p><p><a href="https://medium.com/@imsaravananm/thinking-recursively-1-with-python-ac48ae78201a" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 7, 2023.</p></footer></article></body></html>